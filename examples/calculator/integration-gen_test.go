/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

This file and the project encapsulating it are the confidential intellectual property of Microbus LLC.
Neither may be used, copied or distributed without the express written consent of Microbus LLC.
*/

// Code generated by Microbus. DO NOT EDIT.

package calculator

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/andybalholm/cascadia"
	"github.com/microbus-io/fabric/application"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/frame"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/rand"
	"github.com/microbus-io/fabric/utils"
	"github.com/stretchr/testify/assert"
	"golang.org/x/net/html"

	"github.com/microbus-io/fabric/examples/calculator/calculatorapi"
)

var (
	_ bytes.Buffer
	_ context.Context
	_ fmt.Stringer
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ os.File
	_ time.Time
	_ strings.Builder
	_ cascadia.Sel
	_ *connector.Connector
	_ *errors.TracedError
	_ frame.Frame
	_ *httpx.BodyReader
	_ pub.Option
	_ rand.Void
	_ utils.InfiniteChan[int]
	_ assert.TestingT
	_ *html.Node
	_ *calculatorapi.Client
)

var (
	// App manages the lifecycle of the microservices used in the test
	App *application.Application
	// Svc is the calculator.example microservice being tested
	Svc *Service
)

func TestMain(m *testing.M) {
	var code int

	// Initialize the application
	err := func() error {
		var err error
		App = application.NewTesting()
		Svc = NewService()
		err = Initialize()
		if err != nil {
			return err
		}
		err = App.Startup()
		if err != nil {
			return err
		}
		return nil
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
		code = 19
	}

	// Run the tests
	if err == nil {
		code = m.Run()
	}

	// Terminate the app
	err = func() error {
		var err error
		var lastErr error
		err = Terminate()
		if err != nil {
			lastErr = err
		}
		err = App.Shutdown()
		if err != nil {
			lastErr = err
		}
		return lastErr
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
	}

	os.Exit(code)
}

// Context creates a new context for a test.
func Context(t *testing.T) context.Context {
	ctx := context.Background()
	if deadline, ok := t.Deadline(); ok {
		var cancel context.CancelFunc
		ctx, cancel = context.WithDeadline(ctx, deadline)
		t.Cleanup(cancel)
	}
	ctx = frame.CloneContext(ctx)
	return ctx
}

// ArithmeticTestCase assists in asserting against the results of executing Arithmetic.
type ArithmeticTestCase struct {
	_t *testing.T
	_dur time.Duration
	xEcho int
	opEcho string
	yEcho int
	result int
	err error
}

// Expect asserts no error and exact return values.
func (_tc *ArithmeticTestCase) Expect(xEcho int, opEcho string, yEcho int, result int) *ArithmeticTestCase {
	if assert.NoError(_tc._t, _tc.err) {
		assert.Equal(_tc._t, xEcho, _tc.xEcho)
		assert.Equal(_tc._t, opEcho, _tc.opEcho)
		assert.Equal(_tc._t, yEcho, _tc.yEcho)
		assert.Equal(_tc._t, result, _tc.result)
	}
	return _tc
}

// Error asserts an error.
func (tc *ArithmeticTestCase) Error(errContains string) *ArithmeticTestCase {
	if assert.Error(tc._t, tc.err) {
		assert.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *ArithmeticTestCase) ErrorCode(statusCode int) *ArithmeticTestCase {
	if assert.Error(tc._t, tc.err) {
		assert.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *ArithmeticTestCase) NoError() *ArithmeticTestCase {
	assert.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *ArithmeticTestCase) CompletedIn(threshold time.Duration) *ArithmeticTestCase {
	assert.LessOrEqual(tc._t, tc._dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *ArithmeticTestCase) Assert(asserter func(t *testing.T, xEcho int, opEcho string, yEcho int, result int, err error)) *ArithmeticTestCase {
	asserter(tc._t, tc.xEcho, tc.opEcho, tc.yEcho, tc.result, tc.err)
	return tc
}

// Get returns the result of executing Arithmetic.
func (tc *ArithmeticTestCase) Get() (xEcho int, opEcho string, yEcho int, result int, err error) {
	return tc.xEcho, tc.opEcho, tc.yEcho, tc.result, tc.err
}

// Arithmetic executes the function and returns a corresponding test case.
func Arithmetic(t *testing.T, ctx context.Context, x int, op string, y int) *ArithmeticTestCase {
	tc := &ArithmeticTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.xEcho, tc.opEcho, tc.yEcho, tc.result, tc.err = Svc.Arithmetic(ctx, x, op, y)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// SquareTestCase assists in asserting against the results of executing Square.
type SquareTestCase struct {
	_t *testing.T
	_dur time.Duration
	xEcho int
	result int
	err error
}

// Expect asserts no error and exact return values.
func (_tc *SquareTestCase) Expect(xEcho int, result int) *SquareTestCase {
	if assert.NoError(_tc._t, _tc.err) {
		assert.Equal(_tc._t, xEcho, _tc.xEcho)
		assert.Equal(_tc._t, result, _tc.result)
	}
	return _tc
}

// Error asserts an error.
func (tc *SquareTestCase) Error(errContains string) *SquareTestCase {
	if assert.Error(tc._t, tc.err) {
		assert.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *SquareTestCase) ErrorCode(statusCode int) *SquareTestCase {
	if assert.Error(tc._t, tc.err) {
		assert.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *SquareTestCase) NoError() *SquareTestCase {
	assert.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *SquareTestCase) CompletedIn(threshold time.Duration) *SquareTestCase {
	assert.LessOrEqual(tc._t, tc._dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *SquareTestCase) Assert(asserter func(t *testing.T, xEcho int, result int, err error)) *SquareTestCase {
	asserter(tc._t, tc.xEcho, tc.result, tc.err)
	return tc
}

// Get returns the result of executing Square.
func (tc *SquareTestCase) Get() (xEcho int, result int, err error) {
	return tc.xEcho, tc.result, tc.err
}

// Square executes the function and returns a corresponding test case.
func Square(t *testing.T, ctx context.Context, x int) *SquareTestCase {
	tc := &SquareTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.xEcho, tc.result, tc.err = Svc.Square(ctx, x)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// DistanceTestCase assists in asserting against the results of executing Distance.
type DistanceTestCase struct {
	_t *testing.T
	_dur time.Duration
	d float64
	err error
}

// Expect asserts no error and exact return values.
func (_tc *DistanceTestCase) Expect(d float64) *DistanceTestCase {
	if assert.NoError(_tc._t, _tc.err) {
		assert.Equal(_tc._t, d, _tc.d)
	}
	return _tc
}

// Error asserts an error.
func (tc *DistanceTestCase) Error(errContains string) *DistanceTestCase {
	if assert.Error(tc._t, tc.err) {
		assert.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *DistanceTestCase) ErrorCode(statusCode int) *DistanceTestCase {
	if assert.Error(tc._t, tc.err) {
		assert.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *DistanceTestCase) NoError() *DistanceTestCase {
	assert.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *DistanceTestCase) CompletedIn(threshold time.Duration) *DistanceTestCase {
	assert.LessOrEqual(tc._t, tc._dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *DistanceTestCase) Assert(asserter func(t *testing.T, d float64, err error)) *DistanceTestCase {
	asserter(tc._t, tc.d, tc.err)
	return tc
}

// Get returns the result of executing Distance.
func (tc *DistanceTestCase) Get() (d float64, err error) {
	return tc.d, tc.err
}

// Distance executes the function and returns a corresponding test case.
func Distance(t *testing.T, ctx context.Context, p1 calculatorapi.Point, p2 calculatorapi.Point) *DistanceTestCase {
	tc := &DistanceTestCase{_t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		tc.d, tc.err = Svc.Distance(ctx, p1, p2)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}
