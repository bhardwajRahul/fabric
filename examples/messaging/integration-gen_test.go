/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

This file and the project encapsulating it are the confidential intellectual property of Microbus LLC.
Neither may be used, copied or distributed without the express written consent of Microbus LLC.
*/

// Code generated by Microbus. DO NOT EDIT.

package messaging

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/microbus-io/fabric/application"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/frame"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/utils"

	"github.com/stretchr/testify/assert"

	"github.com/microbus-io/fabric/examples/messaging/messagingapi"
)

var (
	_ bytes.Buffer
	_ context.Context
	_ fmt.Stringer
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ os.File
	_ time.Time
	_ strings.Builder
	_ *connector.Connector
	_ *errors.TracedError
	_ frame.Frame
	_ *httpx.BodyReader
	_ pub.Option
	_ utils.InfiniteChan[int]
	_ assert.TestingT
	_ *messagingapi.Client
)

var (
	sequence int
)

var (
	// App manages the lifecycle of the microservices used in the test
	App *application.Application
	// Svc is the messaging.example microservice being tested
	Svc *Service
)

func TestMain(m *testing.M) {
	var code int

	// Initialize the application
	err := func() error {
		var err error
		App = application.NewTesting()
		Svc = NewService().(*Service)
		err = Initialize()
		if err != nil {
			return err
		}
		err = App.Startup()
		if err != nil {
			return err
		}
		return nil
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
		code = 19
	}

	// Run the tests
	if err == nil {
		code = m.Run()
	}

	// Terminate the app
	err = func() error {
		var err error
		var lastErr error
		err = Terminate()
		if err != nil {
			lastErr = err
		}
		err = App.Shutdown()
		if err != nil {
			lastErr = err
		}
		return lastErr
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
	}

	os.Exit(code)
}

// Context creates a new context for a test.
func Context(t *testing.T) context.Context {
	return context.WithValue(context.Background(), frame.ContextKey, http.Header{})
}

// HomeTestCase assists in asserting against the results of executing Home.
type HomeTestCase struct {
	t *testing.T
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *HomeTestCase) StatusOK() *HomeTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *HomeTestCase) StatusCode(statusCode int) *HomeTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *HomeTestCase) BodyContains(bodyContains any) *HomeTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *HomeTestCase) BodyNotContains(bodyNotContains any) *HomeTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *HomeTestCase) HeaderContains(headerName string, valueContains string) *HomeTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
	}
	return tc
}

// Error asserts an error.
func (tc *HomeTestCase) Error(errContains string) *HomeTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *HomeTestCase) ErrorCode(statusCode int) *HomeTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *HomeTestCase) NoError() *HomeTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// Assert asserts using a provided function.
func (tc *HomeTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *HomeTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Home.
func (tc *HomeTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
HomeGet performs a GET request to the Home endpoint.

Home demonstrates making requests using multicast and unicast request/response patterns.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func HomeGet(t *testing.T, ctx context.Context, url string) *HomeTestCase {
	tc := &HomeTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfHome, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.Home(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
HomePost performs a POST request to the Home endpoint.

Home demonstrates making requests using multicast and unicast request/response patterns.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func HomePost(t *testing.T, ctx context.Context, url string, contentType string, body any) *HomeTestCase {
	tc := &HomeTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfHome, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.Home(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
Home demonstrates making requests using multicast and unicast request/response patterns.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Home(t *testing.T, ctx context.Context, r *http.Request) *HomeTestCase {
	tc := &HomeTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(messagingapi.URLOfHome, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.Home(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

// NoQueueTestCase assists in asserting against the results of executing NoQueue.
type NoQueueTestCase struct {
	t *testing.T
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *NoQueueTestCase) StatusOK() *NoQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *NoQueueTestCase) StatusCode(statusCode int) *NoQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *NoQueueTestCase) BodyContains(bodyContains any) *NoQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *NoQueueTestCase) BodyNotContains(bodyNotContains any) *NoQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *NoQueueTestCase) HeaderContains(headerName string, valueContains string) *NoQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
	}
	return tc
}

// Error asserts an error.
func (tc *NoQueueTestCase) Error(errContains string) *NoQueueTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *NoQueueTestCase) ErrorCode(statusCode int) *NoQueueTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *NoQueueTestCase) NoError() *NoQueueTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// Assert asserts using a provided function.
func (tc *NoQueueTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *NoQueueTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing NoQueue.
func (tc *NoQueueTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
NoQueueGet performs a GET request to the NoQueue endpoint.

NoQueue demonstrates how the NoQueue subscription option is used to create
a multicast request/response communication pattern.
All instances of this microservice will respond to each request.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func NoQueueGet(t *testing.T, ctx context.Context, url string) *NoQueueTestCase {
	tc := &NoQueueTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfNoQueue, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.NoQueue(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
NoQueuePost performs a POST request to the NoQueue endpoint.

NoQueue demonstrates how the NoQueue subscription option is used to create
a multicast request/response communication pattern.
All instances of this microservice will respond to each request.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func NoQueuePost(t *testing.T, ctx context.Context, url string, contentType string, body any) *NoQueueTestCase {
	tc := &NoQueueTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfNoQueue, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.NoQueue(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
NoQueue demonstrates how the NoQueue subscription option is used to create
a multicast request/response communication pattern.
All instances of this microservice will respond to each request.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func NoQueue(t *testing.T, ctx context.Context, r *http.Request) *NoQueueTestCase {
	tc := &NoQueueTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(messagingapi.URLOfNoQueue, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.NoQueue(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

// DefaultQueueTestCase assists in asserting against the results of executing DefaultQueue.
type DefaultQueueTestCase struct {
	t *testing.T
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *DefaultQueueTestCase) StatusOK() *DefaultQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *DefaultQueueTestCase) StatusCode(statusCode int) *DefaultQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *DefaultQueueTestCase) BodyContains(bodyContains any) *DefaultQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *DefaultQueueTestCase) BodyNotContains(bodyNotContains any) *DefaultQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *DefaultQueueTestCase) HeaderContains(headerName string, valueContains string) *DefaultQueueTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
	}
	return tc
}

// Error asserts an error.
func (tc *DefaultQueueTestCase) Error(errContains string) *DefaultQueueTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *DefaultQueueTestCase) ErrorCode(statusCode int) *DefaultQueueTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *DefaultQueueTestCase) NoError() *DefaultQueueTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// Assert asserts using a provided function.
func (tc *DefaultQueueTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *DefaultQueueTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing DefaultQueue.
func (tc *DefaultQueueTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
DefaultQueueGet performs a GET request to the DefaultQueue endpoint.

DefaultQueue demonstrates how the DefaultQueue subscription option is used to create
a unicast request/response communication pattern.
Only one of the instances of this microservice will respond to each request.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func DefaultQueueGet(t *testing.T, ctx context.Context, url string) *DefaultQueueTestCase {
	tc := &DefaultQueueTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfDefaultQueue, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.DefaultQueue(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
DefaultQueuePost performs a POST request to the DefaultQueue endpoint.

DefaultQueue demonstrates how the DefaultQueue subscription option is used to create
a unicast request/response communication pattern.
Only one of the instances of this microservice will respond to each request.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func DefaultQueuePost(t *testing.T, ctx context.Context, url string, contentType string, body any) *DefaultQueueTestCase {
	tc := &DefaultQueueTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfDefaultQueue, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.DefaultQueue(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
DefaultQueue demonstrates how the DefaultQueue subscription option is used to create
a unicast request/response communication pattern.
Only one of the instances of this microservice will respond to each request.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func DefaultQueue(t *testing.T, ctx context.Context, r *http.Request) *DefaultQueueTestCase {
	tc := &DefaultQueueTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(messagingapi.URLOfDefaultQueue, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.DefaultQueue(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

// CacheLoadTestCase assists in asserting against the results of executing CacheLoad.
type CacheLoadTestCase struct {
	t *testing.T
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *CacheLoadTestCase) StatusOK() *CacheLoadTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *CacheLoadTestCase) StatusCode(statusCode int) *CacheLoadTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *CacheLoadTestCase) BodyContains(bodyContains any) *CacheLoadTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *CacheLoadTestCase) BodyNotContains(bodyNotContains any) *CacheLoadTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *CacheLoadTestCase) HeaderContains(headerName string, valueContains string) *CacheLoadTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
	}
	return tc
}

// Error asserts an error.
func (tc *CacheLoadTestCase) Error(errContains string) *CacheLoadTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *CacheLoadTestCase) ErrorCode(statusCode int) *CacheLoadTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *CacheLoadTestCase) NoError() *CacheLoadTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// Assert asserts using a provided function.
func (tc *CacheLoadTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *CacheLoadTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing CacheLoad.
func (tc *CacheLoadTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
CacheLoadGet performs a GET request to the CacheLoad endpoint.

CacheLoad looks up an element in the distributed cache of the microservice.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func CacheLoadGet(t *testing.T, ctx context.Context, url string) *CacheLoadTestCase {
	tc := &CacheLoadTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfCacheLoad, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.CacheLoad(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
CacheLoadPost performs a POST request to the CacheLoad endpoint.

CacheLoad looks up an element in the distributed cache of the microservice.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func CacheLoadPost(t *testing.T, ctx context.Context, url string, contentType string, body any) *CacheLoadTestCase {
	tc := &CacheLoadTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfCacheLoad, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.CacheLoad(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
CacheLoad looks up an element in the distributed cache of the microservice.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func CacheLoad(t *testing.T, ctx context.Context, r *http.Request) *CacheLoadTestCase {
	tc := &CacheLoadTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(messagingapi.URLOfCacheLoad, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.CacheLoad(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

// CacheStoreTestCase assists in asserting against the results of executing CacheStore.
type CacheStoreTestCase struct {
	t *testing.T
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *CacheStoreTestCase) StatusOK() *CacheStoreTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *CacheStoreTestCase) StatusCode(statusCode int) *CacheStoreTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *CacheStoreTestCase) BodyContains(bodyContains any) *CacheStoreTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *CacheStoreTestCase) BodyNotContains(bodyNotContains any) *CacheStoreTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *CacheStoreTestCase) HeaderContains(headerName string, valueContains string) *CacheStoreTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
	}
	return tc
}

// Error asserts an error.
func (tc *CacheStoreTestCase) Error(errContains string) *CacheStoreTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *CacheStoreTestCase) ErrorCode(statusCode int) *CacheStoreTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *CacheStoreTestCase) NoError() *CacheStoreTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// Assert asserts using a provided function.
func (tc *CacheStoreTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *CacheStoreTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing CacheStore.
func (tc *CacheStoreTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
CacheStoreGet performs a GET request to the CacheStore endpoint.

CacheStore stores an element in the distributed cache of the microservice.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func CacheStoreGet(t *testing.T, ctx context.Context, url string) *CacheStoreTestCase {
	tc := &CacheStoreTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfCacheStore, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.CacheStore(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
CacheStorePost performs a POST request to the CacheStore endpoint.

CacheStore stores an element in the distributed cache of the microservice.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func CacheStorePost(t *testing.T, ctx context.Context, url string, contentType string, body any) *CacheStoreTestCase {
	tc := &CacheStoreTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(messagingapi.URLOfCacheStore, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.CacheStore(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
CacheStore stores an element in the distributed cache of the microservice.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func CacheStore(t *testing.T, ctx context.Context, r *http.Request) *CacheStoreTestCase {
	tc := &CacheStoreTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(messagingapi.URLOfCacheStore, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.CacheStore(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}
