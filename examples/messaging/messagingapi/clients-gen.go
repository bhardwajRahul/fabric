/*
Copyright (c) 2023-2025 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package messagingapi implements the public API of the messaging.example microservice,
including clients and data structures.

The Messaging microservice demonstrates service-to-service communication patterns.
*/
package messagingapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
)

// Hostname is the default hostname of the microservice: messaging.example.
const Hostname = "messaging.example"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfHome = httpx.JoinHostAndPath(Hostname, `:443/home`)
	URLOfNoQueue = httpx.JoinHostAndPath(Hostname, `:443/no-queue`)
	URLOfDefaultQueue = httpx.JoinHostAndPath(Hostname, `:443/default-queue`)
	URLOfCacheLoad = httpx.JoinHostAndPath(Hostname, `:443/cache-load`)
	URLOfCacheStore = httpx.JoinHostAndPath(Hostname, `:443/cache-store`)
)

// Client is a lightweight proxy for making unicast calls to the messaging.example microservice.
type Client struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewClient creates a new unicast client proxy to the messaging.example microservice.
func NewClient(caller service.Publisher) Client {
	return Client{
		svc:  caller,
		host: "messaging.example",
	}
}

// ForHost returns a copy of the client with a different hostname to be applied to requests.
func (_c Client) ForHost(host string) Client {
	return Client{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the client with options to be applied to requests.
func (_c Client) WithOptions(opts ...pub.Option) Client {
	return Client{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// MulticastClient is a lightweight proxy for making multicast calls to the messaging.example microservice.
type MulticastClient struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewMulticastClient creates a new multicast client proxy to the messaging.example microservice.
func NewMulticastClient(caller service.Publisher) MulticastClient {
	return MulticastClient{
		svc:  caller,
		host: "messaging.example",
	}
}

// ForHost returns a copy of the client with a different hostname to be applied to requests.
func (_c MulticastClient) ForHost(host string) MulticastClient {
	return MulticastClient{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the client with options to be applied to requests.
func (_c MulticastClient) WithOptions(opts ...pub.Option) MulticastClient {
	return MulticastClient{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// errChan returns a response channel with a single error response.
func (_c MulticastClient) errChan(err error) <-chan *pub.Response {
	ch := make(chan *pub.Response, 1)
	ch <- pub.NewErrorResponse(err)
	close(ch)
	return ch
}

/*
Home demonstrates making requests using multicast and unicast request/response patterns.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c Client) Home(ctx context.Context, relURL string) (res *http.Response, err error) {
	res, err = _c.svc.Request(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfHome),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
Home demonstrates making requests using multicast and unicast request/response patterns.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c MulticastClient) Home(ctx context.Context, relURL string) <-chan *pub.Response {
	return _c.svc.Publish(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfHome),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
}

/*
NoQueue demonstrates how the NoQueue subscription option is used to create
a multicast request/response communication pattern.
All instances of this microservice will respond to each request.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c Client) NoQueue(ctx context.Context, relURL string) (res *http.Response, err error) {
	res, err = _c.svc.Request(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfNoQueue),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
NoQueue demonstrates how the NoQueue subscription option is used to create
a multicast request/response communication pattern.
All instances of this microservice will respond to each request.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c MulticastClient) NoQueue(ctx context.Context, relURL string) <-chan *pub.Response {
	return _c.svc.Publish(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfNoQueue),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
}

/*
DefaultQueue demonstrates how the DefaultQueue subscription option is used to create
a unicast request/response communication pattern.
Only one of the instances of this microservice will respond to each request.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c Client) DefaultQueue(ctx context.Context, relURL string) (res *http.Response, err error) {
	res, err = _c.svc.Request(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfDefaultQueue),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
DefaultQueue demonstrates how the DefaultQueue subscription option is used to create
a unicast request/response communication pattern.
Only one of the instances of this microservice will respond to each request.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c MulticastClient) DefaultQueue(ctx context.Context, relURL string) <-chan *pub.Response {
	return _c.svc.Publish(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfDefaultQueue),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
}

/*
CacheLoad looks up an element in the distributed cache of the microservice.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c Client) CacheLoad(ctx context.Context, relURL string) (res *http.Response, err error) {
	res, err = _c.svc.Request(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfCacheLoad),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
CacheLoad looks up an element in the distributed cache of the microservice.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c MulticastClient) CacheLoad(ctx context.Context, relURL string) <-chan *pub.Response {
	return _c.svc.Publish(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfCacheLoad),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
}

/*
CacheStore stores an element in the distributed cache of the microservice.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c Client) CacheStore(ctx context.Context, relURL string) (res *http.Response, err error) {
	res, err = _c.svc.Request(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfCacheStore),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
CacheStore stores an element in the distributed cache of the microservice.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c MulticastClient) CacheStore(ctx context.Context, relURL string) <-chan *pub.Response {
	return _c.svc.Publish(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfCacheStore),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
}
