/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

This file and the project encapsulating it are the confidential intellectual property of Microbus LLC.
Neither may be used, copied or distributed without the express written consent of Microbus LLC.
*/

// Code generated by Microbus. DO NOT EDIT.

package hello

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/microbus-io/fabric/application"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/frame"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/utils"

	"github.com/stretchr/testify/assert"

	"github.com/microbus-io/fabric/examples/hello/helloapi"
)

var (
	_ bytes.Buffer
	_ context.Context
	_ fmt.Stringer
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ os.File
	_ time.Time
	_ strings.Builder
	_ *connector.Connector
	_ *errors.TracedError
	_ frame.Frame
	_ *httpx.BodyReader
	_ pub.Option
	_ utils.InfiniteChan[int]
	_ assert.TestingT
	_ *helloapi.Client
)

var (
	sequence int
)

var (
	// App manages the lifecycle of the microservices used in the test
	App *application.Application
	// Svc is the hello.example microservice being tested
	Svc *Service
)

func TestMain(m *testing.M) {
	var code int

	// Initialize the application
	err := func() error {
		var err error
		App = application.NewTesting()
		Svc = NewService().(*Service)
		err = Initialize()
		if err != nil {
			return err
		}
		err = App.Startup()
		if err != nil {
			return err
		}
		return nil
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
		code = 19
	}

	// Run the tests
	if err == nil {
		code = m.Run()
	}

	// Terminate the app
	err = func() error {
		var err error
		var lastErr error
		err = Terminate()
		if err != nil {
			lastErr = err
		}
		err = App.Shutdown()
		if err != nil {
			lastErr = err
		}
		return lastErr
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
	}

	os.Exit(code)
}

// Context creates a new context for a test.
func Context(t *testing.T) context.Context {
	return context.WithValue(context.Background(), frame.ContextKey, http.Header{})
}

// HelloTestCase assists in asserting against the results of executing Hello.
type HelloTestCase struct {
	t *testing.T
	res *http.Response
	err error
	dur time.Duration
}

// StatusOK asserts no error and a status code 200.
func (tc *HelloTestCase) StatusOK() *HelloTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *HelloTestCase) StatusCode(statusCode int) *HelloTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *HelloTestCase) BodyContains(bodyContains any) *HelloTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *HelloTestCase) BodyNotContains(bodyNotContains any) *HelloTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *HelloTestCase) HeaderContains(headerName string, value string) *HelloTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *HelloTestCase) HeaderNotContains(headerName string, value string) *HelloTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.False(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" contains "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *HelloTestCase) HeaderExists(headerName string) *HelloTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.NotZero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" does not exist`, headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header exists.
func (tc *HelloTestCase) HeaderNotExists(headerName string) *HelloTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Zero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" exists`, headerName)
	}
	return tc
}

// Error asserts an error.
func (tc *HelloTestCase) Error(errContains string) *HelloTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *HelloTestCase) ErrorCode(statusCode int) *HelloTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *HelloTestCase) NoError() *HelloTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *HelloTestCase) CompletedIn(threshold time.Duration) *HelloTestCase {
	assert.LessOrEqual(tc.t, tc.dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *HelloTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *HelloTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Hello.
func (tc *HelloTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
HelloGet performs a GET request to the Hello endpoint.

Hello prints a greeting.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func HelloGet(t *testing.T, ctx context.Context, url string) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfHello, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
HelloPost performs a POST request to the Hello endpoint.

Hello prints a greeting.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func HelloPost(t *testing.T, ctx context.Context, url string, contentType string, body any) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfHello, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Hello prints a greeting.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Hello(t *testing.T, ctx context.Context, r *http.Request) *HelloTestCase {
	tc := &HelloTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(helloapi.URLOfHello, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Hello(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// EchoTestCase assists in asserting against the results of executing Echo.
type EchoTestCase struct {
	t *testing.T
	res *http.Response
	err error
	dur time.Duration
}

// StatusOK asserts no error and a status code 200.
func (tc *EchoTestCase) StatusOK() *EchoTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *EchoTestCase) StatusCode(statusCode int) *EchoTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *EchoTestCase) BodyContains(bodyContains any) *EchoTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *EchoTestCase) BodyNotContains(bodyNotContains any) *EchoTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *EchoTestCase) HeaderContains(headerName string, value string) *EchoTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *EchoTestCase) HeaderNotContains(headerName string, value string) *EchoTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.False(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" contains "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *EchoTestCase) HeaderExists(headerName string) *EchoTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.NotZero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" does not exist`, headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header exists.
func (tc *EchoTestCase) HeaderNotExists(headerName string) *EchoTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Zero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" exists`, headerName)
	}
	return tc
}

// Error asserts an error.
func (tc *EchoTestCase) Error(errContains string) *EchoTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *EchoTestCase) ErrorCode(statusCode int) *EchoTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *EchoTestCase) NoError() *EchoTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *EchoTestCase) CompletedIn(threshold time.Duration) *EchoTestCase {
	assert.LessOrEqual(tc.t, tc.dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *EchoTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *EchoTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Echo.
func (tc *EchoTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
EchoGet performs a GET request to the Echo endpoint.

Echo back the incoming request in wire format.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func EchoGet(t *testing.T, ctx context.Context, url string) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfEcho, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
EchoPost performs a POST request to the Echo endpoint.

Echo back the incoming request in wire format.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func EchoPost(t *testing.T, ctx context.Context, url string, contentType string, body any) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfEcho, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Echo back the incoming request in wire format.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Echo(t *testing.T, ctx context.Context, r *http.Request) *EchoTestCase {
	tc := &EchoTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(helloapi.URLOfEcho, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Echo(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// PingTestCase assists in asserting against the results of executing Ping.
type PingTestCase struct {
	t *testing.T
	res *http.Response
	err error
	dur time.Duration
}

// StatusOK asserts no error and a status code 200.
func (tc *PingTestCase) StatusOK() *PingTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *PingTestCase) StatusCode(statusCode int) *PingTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *PingTestCase) BodyContains(bodyContains any) *PingTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *PingTestCase) BodyNotContains(bodyNotContains any) *PingTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *PingTestCase) HeaderContains(headerName string, value string) *PingTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *PingTestCase) HeaderNotContains(headerName string, value string) *PingTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.False(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" contains "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *PingTestCase) HeaderExists(headerName string) *PingTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.NotZero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" does not exist`, headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header exists.
func (tc *PingTestCase) HeaderNotExists(headerName string) *PingTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Zero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" exists`, headerName)
	}
	return tc
}

// Error asserts an error.
func (tc *PingTestCase) Error(errContains string) *PingTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *PingTestCase) ErrorCode(statusCode int) *PingTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *PingTestCase) NoError() *PingTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *PingTestCase) CompletedIn(threshold time.Duration) *PingTestCase {
	assert.LessOrEqual(tc.t, tc.dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *PingTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *PingTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Ping.
func (tc *PingTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
PingGet performs a GET request to the Ping endpoint.

Ping all microservices and list them.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func PingGet(t *testing.T, ctx context.Context, url string) *PingTestCase {
	tc := &PingTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfPing, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Ping(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
PingPost performs a POST request to the Ping endpoint.

Ping all microservices and list them.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func PingPost(t *testing.T, ctx context.Context, url string, contentType string, body any) *PingTestCase {
	tc := &PingTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfPing, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Ping(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Ping all microservices and list them.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Ping(t *testing.T, ctx context.Context, r *http.Request) *PingTestCase {
	tc := &PingTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(helloapi.URLOfPing, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Ping(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// CalculatorTestCase assists in asserting against the results of executing Calculator.
type CalculatorTestCase struct {
	t *testing.T
	res *http.Response
	err error
	dur time.Duration
}

// StatusOK asserts no error and a status code 200.
func (tc *CalculatorTestCase) StatusOK() *CalculatorTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *CalculatorTestCase) StatusCode(statusCode int) *CalculatorTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *CalculatorTestCase) BodyContains(bodyContains any) *CalculatorTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *CalculatorTestCase) BodyNotContains(bodyNotContains any) *CalculatorTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *CalculatorTestCase) HeaderContains(headerName string, value string) *CalculatorTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *CalculatorTestCase) HeaderNotContains(headerName string, value string) *CalculatorTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.False(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" contains "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *CalculatorTestCase) HeaderExists(headerName string) *CalculatorTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.NotZero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" does not exist`, headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header exists.
func (tc *CalculatorTestCase) HeaderNotExists(headerName string) *CalculatorTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Zero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" exists`, headerName)
	}
	return tc
}

// Error asserts an error.
func (tc *CalculatorTestCase) Error(errContains string) *CalculatorTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *CalculatorTestCase) ErrorCode(statusCode int) *CalculatorTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *CalculatorTestCase) NoError() *CalculatorTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *CalculatorTestCase) CompletedIn(threshold time.Duration) *CalculatorTestCase {
	assert.LessOrEqual(tc.t, tc.dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *CalculatorTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *CalculatorTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Calculator.
func (tc *CalculatorTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
CalculatorGet performs a GET request to the Calculator endpoint.

Calculator renders a UI for a calculator.
The calculation operation is delegated to another microservice in order to demonstrate
a call from one microservice to another.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func CalculatorGet(t *testing.T, ctx context.Context, url string) *CalculatorTestCase {
	tc := &CalculatorTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfCalculator, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Calculator(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
CalculatorPost performs a POST request to the Calculator endpoint.

Calculator renders a UI for a calculator.
The calculation operation is delegated to another microservice in order to demonstrate
a call from one microservice to another.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func CalculatorPost(t *testing.T, ctx context.Context, url string, contentType string, body any) *CalculatorTestCase {
	tc := &CalculatorTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfCalculator, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Calculator(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Calculator renders a UI for a calculator.
The calculation operation is delegated to another microservice in order to demonstrate
a call from one microservice to another.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Calculator(t *testing.T, ctx context.Context, r *http.Request) *CalculatorTestCase {
	tc := &CalculatorTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(helloapi.URLOfCalculator, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Calculator(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// BusJPEGTestCase assists in asserting against the results of executing BusJPEG.
type BusJPEGTestCase struct {
	t *testing.T
	res *http.Response
	err error
	dur time.Duration
}

// StatusOK asserts no error and a status code 200.
func (tc *BusJPEGTestCase) StatusOK() *BusJPEGTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *BusJPEGTestCase) StatusCode(statusCode int) *BusJPEGTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *BusJPEGTestCase) BodyContains(bodyContains any) *BusJPEGTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *BusJPEGTestCase) BodyNotContains(bodyNotContains any) *BusJPEGTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *BusJPEGTestCase) HeaderContains(headerName string, value string) *BusJPEGTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *BusJPEGTestCase) HeaderNotContains(headerName string, value string) *BusJPEGTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.False(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" contains "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *BusJPEGTestCase) HeaderExists(headerName string) *BusJPEGTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.NotZero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" does not exist`, headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header exists.
func (tc *BusJPEGTestCase) HeaderNotExists(headerName string) *BusJPEGTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Zero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" exists`, headerName)
	}
	return tc
}

// Error asserts an error.
func (tc *BusJPEGTestCase) Error(errContains string) *BusJPEGTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *BusJPEGTestCase) ErrorCode(statusCode int) *BusJPEGTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *BusJPEGTestCase) NoError() *BusJPEGTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *BusJPEGTestCase) CompletedIn(threshold time.Duration) *BusJPEGTestCase {
	assert.LessOrEqual(tc.t, tc.dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *BusJPEGTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *BusJPEGTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing BusJPEG.
func (tc *BusJPEGTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}
/*
BusJPEG serves an image from the embedded resources.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func BusJPEG(t *testing.T, ctx context.Context, url string) *BusJPEGTestCase {
	tc := &BusJPEGTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfBusJPEG, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.BusJPEG(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
BusJPEGAny performs a customized request to the BusJPEG endpoint.

BusJPEG serves an image from the embedded resources.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func BusJPEGAny(t *testing.T, ctx context.Context, r *http.Request) *BusJPEGTestCase {
	tc := &BusJPEGTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(helloapi.URLOfBusJPEG, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.BusJPEG(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// LocalizationTestCase assists in asserting against the results of executing Localization.
type LocalizationTestCase struct {
	t *testing.T
	res *http.Response
	err error
	dur time.Duration
}

// StatusOK asserts no error and a status code 200.
func (tc *LocalizationTestCase) StatusOK() *LocalizationTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *LocalizationTestCase) StatusCode(statusCode int) *LocalizationTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *LocalizationTestCase) BodyContains(bodyContains any) *LocalizationTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *LocalizationTestCase) BodyNotContains(bodyNotContains any) *LocalizationTestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *LocalizationTestCase) HeaderContains(headerName string, value string) *LocalizationTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderNotContains asserts no error and that the named header does not contain a string.
func (tc *LocalizationTestCase) HeaderNotContains(headerName string, value string) *LocalizationTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.False(tc.t, strings.Contains(tc.res.Header.Get(headerName), value), `header "%s: %s" contains "%s"`, headerName, tc.res.Header.Get(headerName), value)
	}
	return tc
}

// HeaderExists asserts no error and that the named header exists.
func (tc *LocalizationTestCase) HeaderExists(headerName string) *LocalizationTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.NotZero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" does not exist`, headerName)
	}
	return tc
}

// HeaderNotExists asserts no error and that the named header exists.
func (tc *LocalizationTestCase) HeaderNotExists(headerName string) *LocalizationTestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Zero(tc.t, len(tc.res.Header.Values(headerName)), `header "%s" exists`, headerName)
	}
	return tc
}

// Error asserts an error.
func (tc *LocalizationTestCase) Error(errContains string) *LocalizationTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *LocalizationTestCase) ErrorCode(statusCode int) *LocalizationTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *LocalizationTestCase) NoError() *LocalizationTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *LocalizationTestCase) CompletedIn(threshold time.Duration) *LocalizationTestCase {
	assert.LessOrEqual(tc.t, tc.dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *LocalizationTestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *LocalizationTestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing Localization.
func (tc *LocalizationTestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

/*
LocalizationGet performs a GET request to the Localization endpoint.

Localization prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func LocalizationGet(t *testing.T, ctx context.Context, url string) *LocalizationTestCase {
	tc := &LocalizationTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfLocalization, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Localization(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
LocalizationPost performs a POST request to the Localization endpoint.

Localization prints hello in the language best matching the request's Accept-Language header.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func LocalizationPost(t *testing.T, ctx context.Context, url string, contentType string, body any) *LocalizationTestCase {
	tc := &LocalizationTestCase{t: t}
	var err error
	url, err = httpx.ResolveURL(helloapi.URLOfLocalization, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Localization(w, r.WithContext(ctx))
	})
	tc.dur = time.Since(t0)
	tc.res = w.Result()
	return tc
}

/*
Localization prints hello in the language best matching the request's Accept-Language header.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func Localization(t *testing.T, ctx context.Context, r *http.Request) *LocalizationTestCase {
	tc := &LocalizationTestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL(helloapi.URLOfLocalization, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.Localization(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	tc.dur = time.Since(t0)
	return tc
}

// TickTockTestCase assists in asserting against the results of executing TickTock.
type TickTockTestCase struct {
	t *testing.T
	err error
	dur time.Duration
}

// Error asserts an error.
func (tc *TickTockTestCase) Error(errContains string) *TickTockTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *TickTockTestCase) ErrorCode(statusCode int) *TickTockTestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *TickTockTestCase) NoError() *TickTockTestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *TickTockTestCase) CompletedIn(threshold time.Duration) *TickTockTestCase {
	assert.LessOrEqual(tc.t, tc.dur, threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *TickTockTestCase) Assert(asserter func(t *testing.T, err error)) *TickTockTestCase {
	asserter(tc.t, tc.err)
	return tc
}

// Get returns the result of executing TickTock.
func (tc *TickTockTestCase) Get() (err error) {
	return tc.err
}

// TickTock executes the ticker and returns a corresponding test case.
func TickTock(t *testing.T, ctx context.Context) *TickTockTestCase {
	tc := &TickTockTestCase{t: t}
	t0 := time.Now()
	tc.err = utils.CatchPanic(func() error {
		return Svc.TickTock(ctx)
	})
	tc.dur = time.Since(t0)
	return tc
}
