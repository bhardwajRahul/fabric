/*
Copyright (c) 2023-2025 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

package tokenissuer

import (
	"bytes"
	"context"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/andybalholm/cascadia"
	"github.com/microbus-io/fabric/application"
	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/frame"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/rand"
	"github.com/microbus-io/fabric/utils"
	"github.com/microbus-io/testarossa"
	"golang.org/x/net/html"

	"github.com/microbus-io/fabric/coreservices/tokenissuer/tokenissuerapi"
)

var (
	_ bytes.Buffer
	_ context.Context
	_ fmt.Stringer
	_ io.Reader
	_ *http.Request
	_ os.File
	_ time.Time
	_ strings.Builder
	_ cascadia.Sel
	_ *connector.Connector
	_ *errors.TracedError
	_ frame.Frame
	_ *httpx.BodyReader
	_ pub.Option
	_ rand.Void
	_ utils.SyncMap[string, string]
	_ testarossa.TestingT
	_ *html.Node
	_ *tokenissuerapi.Client
)

var (
	// App manages the lifecycle of the microservices used in the test
	App *application.Application
	// Svc is the tokenissuer.core microservice being tested
	Svc *Service
)

func TestMain(m *testing.M) {
	var code int

	// Initialize the application
	err := func() error {
		var err error
		App = application.NewTesting()
		Svc = NewService()
		err = Initialize()
		if err != nil {
			return err
		}
		err = App.Startup()
		if err != nil {
			return err
		}
		return nil
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
		code = 19
	}

	// Run the tests
	if err == nil {
		code = m.Run()
	}

	// Terminate the app
	err = func() error {
		var err error
		var lastErr error
		err = App.Shutdown()
		if err != nil {
			lastErr = err
		}
		err = Terminate()
		if err != nil {
			lastErr = err
		}
		return lastErr
	}()
	if err != nil {
		fmt.Fprintf(os.Stderr, "--- FAIL: %+v\n", err)
	}

	os.Exit(code)
}

// Context creates a new context for a test.
func Context() context.Context {
	return frame.ContextWithFrame(context.Background())
}

// IssueTokenTestCase assists in asserting against the results of executing IssueToken.
type IssueTokenTestCase struct {
	_t *testing.T
	_dur time.Duration
	signedToken string
	err error
}

// Expect asserts no error and exact return values.
func (_tc *IssueTokenTestCase) Expect(signedToken string) *IssueTokenTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, signedToken, _tc.signedToken)
	}
	return _tc
}

// Error asserts an error.
func (tc *IssueTokenTestCase) Error(errContains string) *IssueTokenTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *IssueTokenTestCase) ErrorCode(statusCode int) *IssueTokenTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *IssueTokenTestCase) NoError() *IssueTokenTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *IssueTokenTestCase) CompletedIn(threshold time.Duration) *IssueTokenTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *IssueTokenTestCase) Assert(asserter func(t *testing.T, signedToken string, err error)) *IssueTokenTestCase {
	asserter(tc._t, tc.signedToken, tc.err)
	return tc
}

// Get returns the result of executing IssueToken.
func (tc *IssueTokenTestCase) Get() (signedToken string, err error) {
	return tc.signedToken, tc.err
}

// IssueToken executes the function and returns a corresponding test case.
func IssueToken(t *testing.T, ctx context.Context, claims any) *IssueTokenTestCase {
	tc := &IssueTokenTestCase{_t: t}
	t0 := time.Now()
	tc.err = errors.CatchPanic(func() error {
		tc.signedToken, tc.err = Svc.IssueToken(ctx, claims)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}

// ValidateTokenTestCase assists in asserting against the results of executing ValidateToken.
type ValidateTokenTestCase struct {
	_t *testing.T
	_dur time.Duration
	actor any
	valid bool
	err error
}

// Expect asserts no error and exact return values.
func (_tc *ValidateTokenTestCase) Expect(actor any, valid bool) *ValidateTokenTestCase {
	if testarossa.NoError(_tc._t, _tc.err) {
		testarossa.Equal(_tc._t, actor, _tc.actor)
		testarossa.Equal(_tc._t, valid, _tc.valid)
	}
	return _tc
}

// Error asserts an error.
func (tc *ValidateTokenTestCase) Error(errContains string) *ValidateTokenTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Contains(tc._t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *ValidateTokenTestCase) ErrorCode(statusCode int) *ValidateTokenTestCase {
	if testarossa.Error(tc._t, tc.err) {
		testarossa.Equal(tc._t, statusCode, errors.StatusCode(tc.err))
	}
	return tc
}

// NoError asserts no error.
func (tc *ValidateTokenTestCase) NoError() *ValidateTokenTestCase {
	testarossa.NoError(tc._t, tc.err)
	return tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (tc *ValidateTokenTestCase) CompletedIn(threshold time.Duration) *ValidateTokenTestCase {
	testarossa.True(tc._t, tc._dur <= threshold)
	return tc
}

// Assert asserts using a provided function.
func (tc *ValidateTokenTestCase) Assert(asserter func(t *testing.T, actor any, valid bool, err error)) *ValidateTokenTestCase {
	asserter(tc._t, tc.actor, tc.valid, tc.err)
	return tc
}

// Get returns the result of executing ValidateToken.
func (tc *ValidateTokenTestCase) Get() (actor any, valid bool, err error) {
	return tc.actor, tc.valid, tc.err
}

// ValidateToken executes the function and returns a corresponding test case.
func ValidateToken(t *testing.T, ctx context.Context, signedToken string) *ValidateTokenTestCase {
	tc := &ValidateTokenTestCase{_t: t}
	t0 := time.Now()
	tc.err = errors.CatchPanic(func() error {
		tc.actor, tc.valid, tc.err = Svc.ValidateToken(ctx, signedToken)
		return tc.err
	})
	tc._dur = time.Since(t0)
	return tc
}
