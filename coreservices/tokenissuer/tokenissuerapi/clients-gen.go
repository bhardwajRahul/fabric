/*
Copyright (c) 2023-2026 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package tokenissuerapi implements the public API of the tokenissuer.core microservice,
including clients and data structures.

The token issuer microservice generates and validates JWTs.
*/
package tokenissuerapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
)

// Hostname is the default hostname of the microservice: tokenissuer.core.
const Hostname = "tokenissuer.core"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfIssueToken = httpx.JoinHostAndPath(Hostname, `:444/issue-token`)
	URLOfValidateToken = httpx.JoinHostAndPath(Hostname, `:444/validate-token`)
)

// Client is a lightweight proxy for making unicast calls to the tokenissuer.core microservice.
type Client struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewClient creates a new unicast client proxy to the tokenissuer.core microservice.
func NewClient(caller service.Publisher) Client {
	return Client{
		svc:  caller,
		host: "tokenissuer.core",
	}
}

// ForHost returns a copy of the client with a different hostname to be applied to requests.
func (_c Client) ForHost(host string) Client {
	return Client{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the client with options to be applied to requests.
func (_c Client) WithOptions(opts ...pub.Option) Client {
	return Client{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// MulticastClient is a lightweight proxy for making multicast calls to the tokenissuer.core microservice.
type MulticastClient struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewMulticastClient creates a new multicast client proxy to the tokenissuer.core microservice.
func NewMulticastClient(caller service.Publisher) MulticastClient {
	return MulticastClient{
		svc:  caller,
		host: "tokenissuer.core",
	}
}

// ForHost returns a copy of the client with a different hostname to be applied to requests.
func (_c MulticastClient) ForHost(host string) MulticastClient {
	return MulticastClient{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the client with options to be applied to requests.
func (_c MulticastClient) WithOptions(opts ...pub.Option) MulticastClient {
	return MulticastClient{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// IssueTokenIn are the input arguments of IssueToken.
type IssueTokenIn struct {
	Claims MapClaims `json:"claims"`
}

// IssueTokenOut are the return values of IssueToken.
type IssueTokenOut struct {
	SignedToken string `json:"signedToken"`
}

// IssueTokenResponse is the response to IssueToken.
type IssueTokenResponse struct {
	data IssueTokenOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *IssueTokenResponse) Get() (signedToken string, err error) {
	signedToken = _out.data.SignedToken
	err = _out.err
	return
}

/*
IssueToken generates a new JWT with a set of claims.
The claims must be provided as a jwt.MapClaims or an object that can be JSON encoded.
See https://www.iana.org/assignments/jwt/jwt.xhtml for a list of the common claim names.
*/
func (_c MulticastClient) IssueToken(ctx context.Context, claims MapClaims) <-chan *IssueTokenResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:444/issue-token`)
	_in := IssueTokenIn{
		claims,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *IssueTokenResponse, cap(_ch))
	for _i := range _ch {
		var _r IssueTokenResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
IssueToken generates a new JWT with a set of claims.
The claims must be provided as a jwt.MapClaims or an object that can be JSON encoded.
See https://www.iana.org/assignments/jwt/jwt.xhtml for a list of the common claim names.
*/
func (_c Client) IssueToken(ctx context.Context, claims MapClaims) (signedToken string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:444/issue-token`)
	_in := IssueTokenIn{
		claims,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out IssueTokenOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	signedToken = _out.SignedToken
	return
}

// ValidateTokenIn are the input arguments of ValidateToken.
type ValidateTokenIn struct {
	SignedToken string `json:"signedToken"`
}

// ValidateTokenOut are the return values of ValidateToken.
type ValidateTokenOut struct {
	Claims MapClaims `json:"claims"`
	Valid bool `json:"valid"`
}

// ValidateTokenResponse is the response to ValidateToken.
type ValidateTokenResponse struct {
	data ValidateTokenOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *ValidateTokenResponse) Get() (claims MapClaims, valid bool, err error) {
	claims = _out.data.Claims
	valid = _out.data.Valid
	err = _out.err
	return
}

/*
ValidateToken validates a JWT previously generated by this issuer and returns the claims associated with it.
*/
func (_c MulticastClient) ValidateToken(ctx context.Context, signedToken string) <-chan *ValidateTokenResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:444/validate-token`)
	_in := ValidateTokenIn{
		signedToken,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *ValidateTokenResponse, cap(_ch))
	for _i := range _ch {
		var _r ValidateTokenResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
ValidateToken validates a JWT previously generated by this issuer and returns the claims associated with it.
*/
func (_c Client) ValidateToken(ctx context.Context, signedToken string) (claims MapClaims, valid bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:444/validate-token`)
	_in := ValidateTokenIn{
		signedToken,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out ValidateTokenOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	claims = _out.Claims
	valid = _out.Valid
	return
}
