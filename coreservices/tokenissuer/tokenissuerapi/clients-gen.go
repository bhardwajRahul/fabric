/*
Copyright (c) 2023-2025 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package tokenissuerapi implements the public API of the tokenissuer.core microservice,
including clients and data structures.

The token issuer microservice generates and validates JWTs.
*/
package tokenissuerapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
)

// Hostname is the default hostname of the microservice: tokenissuer.core.
const Hostname = "tokenissuer.core"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfIssueToken = httpx.JoinHostAndPath(Hostname, `:444/issue-token`)
	URLOfValidateToken = httpx.JoinHostAndPath(Hostname, `:444/validate-token`)
)

// Client is an interface to calling the endpoints of the tokenissuer.core microservice.
// This simple version is for unicast calls.
type Client struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewClient creates a new unicast client to the tokenissuer.core microservice.
func NewClient(caller service.Publisher) *Client {
	return &Client{
		svc:  caller,
		host: "tokenissuer.core",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *Client) ForHost(host string) *Client {
	_c.host = host
	return _c
}

// WithOptions applies options to requests made by this client.
func (_c *Client) WithOptions(opts ...pub.Option) *Client {
	_c.opts = append(_c.opts, opts...)
	return _c
}

// MulticastClient is an interface to calling the endpoints of the tokenissuer.core microservice.
// This advanced version is for multicast calls.
type MulticastClient struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewMulticastClient creates a new multicast client to the tokenissuer.core microservice.
func NewMulticastClient(caller service.Publisher) *MulticastClient {
	return &MulticastClient{
		svc:  caller,
		host: "tokenissuer.core",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *MulticastClient) ForHost(host string) *MulticastClient {
	_c.host = host
	return _c
}

// WithOptions applies options to requests made by this client.
func (_c *MulticastClient) WithOptions(opts ...pub.Option) *MulticastClient {
	_c.opts = append(_c.opts, opts...)
	return _c
}

// IssueTokenIn are the input arguments of IssueToken.
type IssueTokenIn struct {
	Claims any `json:"claims"`
}

// IssueTokenOut are the return values of IssueToken.
type IssueTokenOut struct {
	SignedToken string `json:"signedToken"`
}

// IssueTokenResponse is the response to IssueToken.
type IssueTokenResponse struct {
	data IssueTokenOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *IssueTokenResponse) Get() (signedToken string, err error) {
	signedToken = _out.data.SignedToken
	err = _out.err
	return
}

/*
IssueToken generates a new JWT with a set of claims.
The claims must be provided as a jwt.MapClaims or an object that can be JSON encoded.
See https://www.iana.org/assignments/jwt/jwt.xhtml for a list of the common claim names.
*/
func (_c *MulticastClient) IssueToken(ctx context.Context, claims any) <-chan *IssueTokenResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:444/issue-token`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`claims`: claims,
	})
	_in := IssueTokenIn{
		claims,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *IssueTokenResponse, cap(_ch))
	for _i := range _ch {
		var _r IssueTokenResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
IssueToken generates a new JWT with a set of claims.
The claims must be provided as a jwt.MapClaims or an object that can be JSON encoded.
See https://www.iana.org/assignments/jwt/jwt.xhtml for a list of the common claim names.
*/
func (_c *Client) IssueToken(ctx context.Context, claims any) (signedToken string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:444/issue-token`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`claims`: claims,
	})
	_in := IssueTokenIn{
		claims,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out IssueTokenOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	signedToken = _out.SignedToken
	return
}

// ValidateTokenIn are the input arguments of ValidateToken.
type ValidateTokenIn struct {
	SignedToken string `json:"signedToken"`
}

// ValidateTokenOut are the return values of ValidateToken.
type ValidateTokenOut struct {
	Actor any `json:"actor"`
	Valid bool `json:"valid"`
}

// ValidateTokenResponse is the response to ValidateToken.
type ValidateTokenResponse struct {
	data ValidateTokenOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *ValidateTokenResponse) Get() (actor any, valid bool, err error) {
	actor = _out.data.Actor
	valid = _out.data.Valid
	err = _out.err
	return
}

/*
ValidateToken validates a JWT previously generated by this issuer and returns the actor associated with it.
*/
func (_c *MulticastClient) ValidateToken(ctx context.Context, signedToken string) <-chan *ValidateTokenResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:444/validate-token`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`signedToken`: signedToken,
	})
	_in := ValidateTokenIn{
		signedToken,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *ValidateTokenResponse, cap(_ch))
	for _i := range _ch {
		var _r ValidateTokenResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
ValidateToken validates a JWT previously generated by this issuer and returns the actor associated with it.
*/
func (_c *Client) ValidateToken(ctx context.Context, signedToken string) (actor any, valid bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:444/validate-token`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`signedToken`: signedToken,
	})
	_in := ValidateTokenIn{
		signedToken,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out ValidateTokenOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	actor = _out.Actor
	valid = _out.Valid
	return
}
