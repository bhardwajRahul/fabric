/*
Copyright (c) 2023-2026 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package controlapi implements the public API of the control.core microservice,
including clients and data structures.

This microservice is created for the sake of generating the client API for the :888 control subscriptions.
The microservice itself does nothing and should not be included in applications.
*/
package controlapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
)

// Hostname is the default hostname of the microservice: control.core.
const Hostname = "control.core"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfPing = httpx.JoinHostAndPath(Hostname, `:888/ping`)
	URLOfConfigRefresh = httpx.JoinHostAndPath(Hostname, `:888/config-refresh`)
	URLOfTrace = httpx.JoinHostAndPath(Hostname, `:888/trace`)
	URLOfMetrics = httpx.JoinHostAndPath(Hostname, `:888/metrics`)
)

// Client is a lightweight proxy for making unicast calls to the control.core microservice.
type Client struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewClient creates a new unicast client proxy to the control.core microservice.
func NewClient(caller service.Publisher) Client {
	return Client{
		svc:  caller,
		host: "control.core",
	}
}

// ForHost returns a copy of the client with a different hostname to be applied to requests.
func (_c Client) ForHost(host string) Client {
	return Client{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the client with options to be applied to requests.
func (_c Client) WithOptions(opts ...pub.Option) Client {
	return Client{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// MulticastClient is a lightweight proxy for making multicast calls to the control.core microservice.
type MulticastClient struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewMulticastClient creates a new multicast client proxy to the control.core microservice.
func NewMulticastClient(caller service.Publisher) MulticastClient {
	return MulticastClient{
		svc:  caller,
		host: "control.core",
	}
}

// ForHost returns a copy of the client with a different hostname to be applied to requests.
func (_c MulticastClient) ForHost(host string) MulticastClient {
	return MulticastClient{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the client with options to be applied to requests.
func (_c MulticastClient) WithOptions(opts ...pub.Option) MulticastClient {
	return MulticastClient{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// MulticastTrigger is a lightweight proxy for triggering the events of the control.core microservice.
type MulticastTrigger struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewMulticastTrigger creates a new multicast trigger of events of the control.core microservice.
func NewMulticastTrigger(caller service.Publisher) MulticastTrigger {
	return MulticastTrigger{
		svc:  caller,
		host: "control.core",
	}
}

// ForHost returns a copy of the trigger with a different hostname to be applied to requests.
func (_c MulticastTrigger) ForHost(host string) MulticastTrigger {
	return MulticastTrigger{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the trigger with options to be applied to requests.
func (_c MulticastTrigger) WithOptions(opts ...pub.Option) MulticastTrigger {
	return MulticastTrigger{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// Hook assists in the subscription to the events of the control.core microservice.
type Hook struct {
	svc  service.Subscriber
	host string
}

// NewHook creates a new hook to the events of the control.core microservice.
func NewHook(listener service.Subscriber) Hook {
	return Hook{
		svc:  listener,
		host: "control.core",
	}
}

// ForHost returns a copy of the hook with a different hostname to be applied to the subscription.
func (_c Hook) ForHost(host string) Hook {
	return Hook{
		svc:  _c.svc,
		host: host,
	}
}

// errChan returns a response channel with a single error response.
func (_c MulticastClient) errChan(err error) <-chan *pub.Response {
	ch := make(chan *pub.Response, 1)
	ch <- pub.NewErrorResponse(err)
	close(ch)
	return ch
}

/*
Metrics returns the Prometheus metrics collected by the microservice.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c Client) Metrics(ctx context.Context, method string, relURL string, contentType string, body any) (res *http.Response, err error) {
	if method == "" {
		method = "POST"
	}
	res, err = _c.svc.Request(
		ctx,
		pub.Method(method),
		pub.URL(URLOfMetrics),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
Metrics returns the Prometheus metrics collected by the microservice.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c MulticastClient) Metrics(ctx context.Context, method string, relURL string, contentType string, body any) <-chan *pub.Response {
	if method == "" {
		method = "POST"
	}
	return _c.svc.Publish(
		ctx,
		pub.Method(method),
		pub.URL(URLOfMetrics),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
}

// PingIn are the input arguments of Ping.
type PingIn struct {
}

// PingOut are the return values of Ping.
type PingOut struct {
	Pong int `json:"pong"`
}

// PingResponse is the response to Ping.
type PingResponse struct {
	data PingOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *PingResponse) Get() (pong int, err error) {
	pong = _out.data.Pong
	err = _out.err
	return
}

/*
Ping responds to the message with a pong.
*/
func (_c MulticastClient) Ping(ctx context.Context) <-chan *PingResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:888/ping`)
	_in := PingIn{
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *PingResponse, cap(_ch))
	for _i := range _ch {
		var _r PingResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
Ping responds to the message with a pong.
*/
func (_c Client) Ping(ctx context.Context) (pong int, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:888/ping`)
	_in := PingIn{
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out PingOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	pong = _out.Pong
	return
}

// ConfigRefreshIn are the input arguments of ConfigRefresh.
type ConfigRefreshIn struct {
}

// ConfigRefreshOut are the return values of ConfigRefresh.
type ConfigRefreshOut struct {
}

// ConfigRefreshResponse is the response to ConfigRefresh.
type ConfigRefreshResponse struct {
	data ConfigRefreshOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *ConfigRefreshResponse) Get() (err error) {
	err = _out.err
	return
}

/*
ConfigRefresh pulls the latest config values from the configurator microservice.
*/
func (_c MulticastClient) ConfigRefresh(ctx context.Context) <-chan *ConfigRefreshResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:888/config-refresh`)
	_in := ConfigRefreshIn{
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *ConfigRefreshResponse, cap(_ch))
	for _i := range _ch {
		var _r ConfigRefreshResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
ConfigRefresh pulls the latest config values from the configurator microservice.
*/
func (_c Client) ConfigRefresh(ctx context.Context) (err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:888/config-refresh`)
	_in := ConfigRefreshIn{
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out ConfigRefreshOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}

// TraceIn are the input arguments of Trace.
type TraceIn struct {
	ID string `json:"id"`
}

// TraceOut are the return values of Trace.
type TraceOut struct {
}

// TraceResponse is the response to Trace.
type TraceResponse struct {
	data TraceOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *TraceResponse) Get() (err error) {
	err = _out.err
	return
}

/*
Trace forces exporting the indicated tracing span.
*/
func (_c MulticastClient) Trace(ctx context.Context, id string) <-chan *TraceResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:888/trace`)
	_in := TraceIn{
		id,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *TraceResponse, cap(_ch))
	for _i := range _ch {
		var _r TraceResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
Trace forces exporting the indicated tracing span.
*/
func (_c Client) Trace(ctx context.Context, id string) (err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:888/trace`)
	_in := TraceIn{
		id,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out TraceOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}

// OnNewSubsIn are the input arguments of OnNewSubs.
type OnNewSubsIn struct {
	Hosts []string `json:"hosts"`
}

// OnNewSubsOut are the return values of OnNewSubs.
type OnNewSubsOut struct {
}

// OnNewSubsResponse is the response to OnNewSubs.
type OnNewSubsResponse struct {
	data OnNewSubsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *OnNewSubsResponse) Get() (err error) {
	err = _out.err
	return
}

/*
OnNewSubs informs other microservices of new subscriptions, enabling them to update their known responders cache appropriately.
*/
func (_c MulticastTrigger) OnNewSubs(ctx context.Context, hosts []string) <-chan *OnNewSubsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:888/on-new-subs`)
	_in := OnNewSubsIn{
		hosts,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *OnNewSubsResponse, cap(_ch))
	for _i := range _ch {
		var _r OnNewSubsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
OnNewSubs informs other microservices of new subscriptions, enabling them to update their known responders cache appropriately.
*/
func (_c Hook) OnNewSubs(handler func(ctx context.Context, hosts []string) (err error)) (err error) {
	doOnNewSubs := func(w http.ResponseWriter, r *http.Request) error {
		var i OnNewSubsIn
		var o OnNewSubsOut
		err = httpx.ParseRequest(r, `:888/on-new-subs`, &i, &i, &i)
		if err != nil {
			return errors.Trace(err)
		}
		err = handler(
			r.Context(),
			i.Hosts,
		)
		if err != nil {
			return err // No trace
		}
		w.Header().Set("Content-Type", "application/json")
		encoder := json.NewEncoder(w)
		err = encoder.Encode(o)
		if err != nil {
			return errors.Trace(err)
		}
		return nil
	}
	path := httpx.JoinHostAndPath(_c.host, `:888/on-new-subs`)
	if handler == nil {
		return _c.svc.Unsubscribe(`POST`, path)
	}
	return _c.svc.Subscribe(`POST`, path, doOnNewSubs)
}
