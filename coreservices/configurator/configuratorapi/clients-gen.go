/*
Copyright (c) 2023-2025 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package configuratorapi implements the public API of the configurator.core microservice,
including clients and data structures.

The Configurator is a core microservice that centralizes the dissemination of configuration values to other microservices.
*/
package configuratorapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
)

// Hostname is the default hostname of the microservice: configurator.core.
const Hostname = "configurator.core"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfValues = httpx.JoinHostAndPath(Hostname, `:888/values`)
	URLOfRefresh = httpx.JoinHostAndPath(Hostname, `:444/refresh`)
	URLOfSyncRepo = httpx.JoinHostAndPath(Hostname, `:888/sync-repo`)
	URLOfValues443 = httpx.JoinHostAndPath(Hostname, `:443/values`)
	URLOfRefresh443 = httpx.JoinHostAndPath(Hostname, `:443/refresh`)
	URLOfSync443 = httpx.JoinHostAndPath(Hostname, `:443/sync`)
)

// Client is an interface to calling the endpoints of the configurator.core microservice.
// This simple version is for unicast calls.
type Client struct {
	svc  service.Publisher
	host string
}

// NewClient creates a new unicast client to the configurator.core microservice.
func NewClient(caller service.Publisher) *Client {
	return &Client{
		svc:  caller,
		host: "configurator.core",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *Client) ForHost(host string) *Client {
	_c.host = host
	return _c
}

// MulticastClient is an interface to calling the endpoints of the configurator.core microservice.
// This advanced version is for multicast calls.
type MulticastClient struct {
	svc  service.Publisher
	host string
}

// NewMulticastClient creates a new multicast client to the configurator.core microservice.
func NewMulticastClient(caller service.Publisher) *MulticastClient {
	return &MulticastClient{
		svc:  caller,
		host: "configurator.core",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *MulticastClient) ForHost(host string) *MulticastClient {
	_c.host = host
	return _c
}

// ValuesIn are the input arguments of Values.
type ValuesIn struct {
	Names []string `json:"names"`
}

// ValuesOut are the return values of Values.
type ValuesOut struct {
	Values map[string]string `json:"values"`
}

// ValuesResponse is the response to Values.
type ValuesResponse struct {
	data ValuesOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *ValuesResponse) Get() (values map[string]string, err error) {
	values = _out.data.Values
	err = _out.err
	return
}

/*
Values returns the values associated with the specified config property names for the caller microservice.
*/
func (_c *MulticastClient) Values(ctx context.Context, names []string) <-chan *ValuesResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:888/values`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`names`: names,
	})
	_in := ValuesIn{
		names,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *ValuesResponse, cap(_ch))
	for _i := range _ch {
		var _r ValuesResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
Values returns the values associated with the specified config property names for the caller microservice.
*/
func (_c *Client) Values(ctx context.Context, names []string) (values map[string]string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:888/values`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`names`: names,
	})
	_in := ValuesIn{
		names,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out ValuesOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	values = _out.Values
	return
}

// RefreshIn are the input arguments of Refresh.
type RefreshIn struct {
}

// RefreshOut are the return values of Refresh.
type RefreshOut struct {
}

// RefreshResponse is the response to Refresh.
type RefreshResponse struct {
	data RefreshOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *RefreshResponse) Get() (err error) {
	err = _out.err
	return
}

/*
Refresh tells all microservices to contact the configurator and refresh their configs.
An error is returned if any of the values sent to the microservices fails validation.
*/
func (_c *MulticastClient) Refresh(ctx context.Context) <-chan *RefreshResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:444/refresh`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
	})
	_in := RefreshIn{
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *RefreshResponse, cap(_ch))
	for _i := range _ch {
		var _r RefreshResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
Refresh tells all microservices to contact the configurator and refresh their configs.
An error is returned if any of the values sent to the microservices fails validation.
*/
func (_c *Client) Refresh(ctx context.Context) (err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:444/refresh`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
	})
	_in := RefreshIn{
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out RefreshOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}

// SyncRepoIn are the input arguments of SyncRepo.
type SyncRepoIn struct {
	Timestamp time.Time `json:"timestamp"`
	Values map[string]map[string]string `json:"values"`
}

// SyncRepoOut are the return values of SyncRepo.
type SyncRepoOut struct {
}

// SyncRepoResponse is the response to SyncRepo.
type SyncRepoResponse struct {
	data SyncRepoOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SyncRepoResponse) Get() (err error) {
	err = _out.err
	return
}

/*
SyncRepo is used to synchronize values among replica peers of the configurator.
*/
func (_c *MulticastClient) SyncRepo(ctx context.Context, timestamp time.Time, values map[string]map[string]string) <-chan *SyncRepoResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:888/sync-repo`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`timestamp`: timestamp,
		`values`: values,
	})
	_in := SyncRepoIn{
		timestamp,
		values,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *SyncRepoResponse, cap(_ch))
	for _i := range _ch {
		var _r SyncRepoResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
SyncRepo is used to synchronize values among replica peers of the configurator.
*/
func (_c *Client) SyncRepo(ctx context.Context, timestamp time.Time, values map[string]map[string]string) (err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:888/sync-repo`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`timestamp`: timestamp,
		`values`: values,
	})
	_in := SyncRepoIn{
		timestamp,
		values,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out SyncRepoOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}

// Values443In are the input arguments of Values443.
type Values443In struct {
	Names []string `json:"names"`
}

// Values443Out are the return values of Values443.
type Values443Out struct {
	Values map[string]string `json:"values"`
}

// Values443Response is the response to Values443.
type Values443Response struct {
	data Values443Out
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *Values443Response) Get() (values map[string]string, err error) {
	values = _out.data.Values
	err = _out.err
	return
}

/*
Values443 is deprecated.
*/
func (_c *MulticastClient) Values443(ctx context.Context, names []string) <-chan *Values443Response {
	_url := httpx.JoinHostAndPath(_c.host, `:443/values`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`names`: names,
	})
	_in := Values443In{
		names,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *Values443Response, cap(_ch))
	for _i := range _ch {
		var _r Values443Response
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
Values443 is deprecated.
*/
func (_c *Client) Values443(ctx context.Context, names []string) (values map[string]string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/values`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`names`: names,
	})
	_in := Values443In{
		names,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out Values443Out
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	values = _out.Values
	return
}

// Refresh443In are the input arguments of Refresh443.
type Refresh443In struct {
}

// Refresh443Out are the return values of Refresh443.
type Refresh443Out struct {
}

// Refresh443Response is the response to Refresh443.
type Refresh443Response struct {
	data Refresh443Out
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *Refresh443Response) Get() (err error) {
	err = _out.err
	return
}

/*
Refresh443 is deprecated.
*/
func (_c *MulticastClient) Refresh443(ctx context.Context) <-chan *Refresh443Response {
	_url := httpx.JoinHostAndPath(_c.host, `:443/refresh`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
	})
	_in := Refresh443In{
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *Refresh443Response, cap(_ch))
	for _i := range _ch {
		var _r Refresh443Response
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
Refresh443 is deprecated.
*/
func (_c *Client) Refresh443(ctx context.Context) (err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/refresh`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
	})
	_in := Refresh443In{
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out Refresh443Out
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}

// Sync443In are the input arguments of Sync443.
type Sync443In struct {
	Timestamp time.Time `json:"timestamp"`
	Values map[string]map[string]string `json:"values"`
}

// Sync443Out are the return values of Sync443.
type Sync443Out struct {
}

// Sync443Response is the response to Sync443.
type Sync443Response struct {
	data Sync443Out
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *Sync443Response) Get() (err error) {
	err = _out.err
	return
}

/*
Sync443 is deprecated.
*/
func (_c *MulticastClient) Sync443(ctx context.Context, timestamp time.Time, values map[string]map[string]string) <-chan *Sync443Response {
	_url := httpx.JoinHostAndPath(_c.host, `:443/sync`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`timestamp`: timestamp,
		`values`: values,
	})
	_in := Sync443In{
		timestamp,
		values,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *Sync443Response, cap(_ch))
	for _i := range _ch {
		var _r Sync443Response
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
Sync443 is deprecated.
*/
func (_c *Client) Sync443(ctx context.Context, timestamp time.Time, values map[string]map[string]string) (err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/sync`)
	_url = httpx.InsertPathArguments(_url, httpx.QArgs{
		`timestamp`: timestamp,
		`values`: values,
	})
	_in := Sync443In{
		timestamp,
		values,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out Sync443Out
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}
