/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

This file and the project encapsulating it are the confidential intellectual property of Microbus LLC.
Neither may be used, copied or distributed without the express written consent of Microbus LLC.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package testerapi implements the public API of the codegen.test microservice,
including clients and data structures.

The tester is used to test the code generator's functions.
*/
package testerapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
	"github.com/microbus-io/fabric/sub"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
	_ sub.Option
)

// Hostname is the default hostname of the microservice: codegen.test.
const Hostname = "codegen.test"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfStringCut = httpx.JoinHostAndPath(Hostname, `:443/string-cut`)
	URLOfPointDistance = httpx.JoinHostAndPath(Hostname, `:443/point-distance`)
	URLOfSubArrayRange = httpx.JoinHostAndPath(Hostname, `:443/sub-array-range/{max}`)
	URLOfSumTwoIntegers = httpx.JoinHostAndPath(Hostname, `:443/sum-two-integers`)
	URLOfFunctionPathArguments = httpx.JoinHostAndPath(Hostname, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfNonStringPathArguments = httpx.JoinHostAndPath(Hostname, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfUnnamedFunctionPathArguments = httpx.JoinHostAndPath(Hostname, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	URLOfEcho = httpx.JoinHostAndPath(Hostname, `:443/echo`)
	URLOfWebPathArguments = httpx.JoinHostAndPath(Hostname, `:443/web-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfUnnamedWebPathArguments = httpx.JoinHostAndPath(Hostname, `:443/unnamed-web-path-arguments/{}/foo/{}/bar/{+}`)
)

// Client is an interface to calling the endpoints of the codegen.test microservice.
// This simple version is for unicast calls.
type Client struct {
	svc  service.Publisher
	host string
}

// NewClient creates a new unicast client to the codegen.test microservice.
func NewClient(caller service.Publisher) *Client {
	return &Client{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *Client) ForHost(host string) *Client {
	_c.host = host
	return _c
}

// MulticastClient is an interface to calling the endpoints of the codegen.test microservice.
// This advanced version is for multicast calls.
type MulticastClient struct {
	svc  service.Publisher
	host string
}

// NewMulticastClient creates a new multicast client to the codegen.test microservice.
func NewMulticastClient(caller service.Publisher) *MulticastClient {
	return &MulticastClient{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *MulticastClient) ForHost(host string) *MulticastClient {
	_c.host = host
	return _c
}

// errChan returns a response channel with a single error response.
func (_c *MulticastClient) errChan(err error) <-chan *pub.Response {
	ch := make(chan *pub.Response, 1)
	ch <- pub.NewErrorResponse(err)
	close(ch)
	return ch
}

/*
Echo_Get performs a GET request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) Echo_Get(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfEcho, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("GET"), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Echo_Get performs a GET request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) Echo_Get(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfEcho, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("GET"), pub.URL(url))
}

/*
Echo_Post performs a POST request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) Echo_Post(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfEcho, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Echo_Post performs a POST request to the Echo endpoint.

Echo tests a typical web handler.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) Echo_Post(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfEcho, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

/*
Echo tests a typical web handler.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) Echo(ctx context.Context, r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := httpx.ResolveURL(URLOfEcho, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
Echo tests a typical web handler.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) Echo(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := httpx.ResolveURL(URLOfEcho, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

/*
WebPathArguments_Get performs a GET request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) WebPathArguments_Get(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("GET"), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments_Get performs a GET request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) WebPathArguments_Get(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("GET"), pub.URL(url))
}

/*
WebPathArguments_Post performs a POST request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) WebPathArguments_Post(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments_Post performs a POST request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) WebPathArguments_Post(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

/*
WebPathArguments tests path arguments in web handlers.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) WebPathArguments(ctx context.Context, r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := httpx.ResolveURL(URLOfWebPathArguments, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments tests path arguments in web handlers.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) WebPathArguments(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := httpx.ResolveURL(URLOfWebPathArguments, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

/*
UnnamedWebPathArguments tests path arguments that are not named.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) UnnamedWebPathArguments(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfUnnamedWebPathArguments, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(`GET`), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
UnnamedWebPathArguments tests path arguments that are not named.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) UnnamedWebPathArguments(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfUnnamedWebPathArguments, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(`GET`), pub.URL(url))
}

/*
UnnamedWebPathArguments_Do performs a customized request to the UnnamedWebPathArguments endpoint.

UnnamedWebPathArguments tests path arguments that are not named.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) UnnamedWebPathArguments_Do(ctx context.Context, r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := httpx.ResolveURL(URLOfUnnamedWebPathArguments, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
UnnamedWebPathArguments_Do performs a customized request to the UnnamedWebPathArguments endpoint.

UnnamedWebPathArguments tests path arguments that are not named.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) UnnamedWebPathArguments_Do(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := httpx.ResolveURL(URLOfUnnamedWebPathArguments, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

// StringCutIn are the input arguments of StringCut.
type StringCutIn struct {
	S string `json:"s"`
	Sep string `json:"sep"`
}

// StringCutOut are the return values of StringCut.
type StringCutOut struct {
	Before string `json:"before"`
	After string `json:"after"`
	Found bool `json:"found"`
}

// StringCutResponse is the response to StringCut.
type StringCutResponse struct {
	data StringCutOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *StringCutResponse) Get() (before string, after string, found bool, err error) {
	before = _out.data.Before
	after = _out.data.After
	found = _out.data.Found
	err = _out.err
	return
}

/*
StringCut tests a standard function that takes multiple input arguments and returns multiple values.
*/
func (_c *MulticastClient) StringCut(ctx context.Context, s string, sep string) <-chan *StringCutResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/string-cut`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`s`: s,
		`sep`: sep,
	})
	_in := StringCutIn{
		s,
		sep,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *StringCutResponse, cap(_ch))
	for _i := range _ch {
		var _r StringCutResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
StringCut tests a standard function that takes multiple input arguments and returns multiple values.
*/
func (_c *Client) StringCut(ctx context.Context, s string, sep string) (before string, after string, found bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/string-cut`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`s`: s,
		`sep`: sep,
	})
	_in := StringCutIn{
		s,
		sep,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out StringCutOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	before = _out.Before
	after = _out.After
	found = _out.Found
	return
}

// PointDistanceIn are the input arguments of PointDistance.
type PointDistanceIn struct {
	P1 XYCoord `json:"p1"`
	P2 *XYCoord `json:"p2"`
}

// PointDistanceOut are the return values of PointDistance.
type PointDistanceOut struct {
	D float64 `json:"d"`
}

// PointDistanceResponse is the response to PointDistance.
type PointDistanceResponse struct {
	data PointDistanceOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *PointDistanceResponse) Get() (d float64, err error) {
	d = _out.data.D
	err = _out.err
	return
}

/*
PointDistance tests passing non-primitive types via query arguments.
*/
func (_c *MulticastClient) PointDistance(ctx context.Context, p1 XYCoord, p2 *XYCoord) <-chan *PointDistanceResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/point-distance`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`p1`: p1,
		`p2`: p2,
	})
	_in := PointDistanceIn{
		p1,
		p2,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *PointDistanceResponse, 1)
		_res <- &PointDistanceResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *PointDistanceResponse, cap(_ch))
	for _i := range _ch {
		var _r PointDistanceResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
PointDistance tests passing non-primitive types via query arguments.
*/
func (_c *Client) PointDistance(ctx context.Context, p1 XYCoord, p2 *XYCoord) (d float64, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/point-distance`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`p1`: p1,
		`p2`: p2,
	})
	_in := PointDistanceIn{
		p1,
		p2,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out PointDistanceOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	d = _out.D
	return
}

// SubArrayRangeIn are the input arguments of SubArrayRange.
type SubArrayRangeIn struct {
	HTTPRequestBody []int `json:"-"`
	Min int `json:"min"`
	Max int `json:"max"`
}

// SubArrayRangeOut are the return values of SubArrayRange.
type SubArrayRangeOut struct {
	HTTPResponseBody []int `json:"httpResponseBody"`
	HTTPStatusCode int `json:"-"`
}

// SubArrayRangeResponse is the response to SubArrayRange.
type SubArrayRangeResponse struct {
	data SubArrayRangeOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SubArrayRangeResponse) Get() (httpResponseBody []int, httpStatusCode int, err error) {
	httpResponseBody = _out.data.HTTPResponseBody
	httpStatusCode = _out.data.HTTPStatusCode
	err = _out.err
	return
}

/*
SubArrayRange tests sending arguments as the entire request and response bodies.
An httpRequestBody argument allows sending other arguments via query or path.
An httpResponseBody argument prevents returning additional values, except for the status code.
*/
func (_c *MulticastClient) SubArrayRange(ctx context.Context, httpRequestBody []int, min int, max int) <-chan *SubArrayRangeResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/sub-array-range/{max}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`min`: min,
		`max`: max,
	})
	_in := SubArrayRangeIn{
		httpRequestBody,
		min,
		max,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *SubArrayRangeResponse, 1)
		_res <- &SubArrayRangeResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	_body := httpRequestBody
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *SubArrayRangeResponse, cap(_ch))
	for _i := range _ch {
		var _r SubArrayRangeResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data.HTTPResponseBody))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
			_r.data.HTTPStatusCode = _httpRes.StatusCode
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
SubArrayRange tests sending arguments as the entire request and response bodies.
An httpRequestBody argument allows sending other arguments via query or path.
An httpResponseBody argument prevents returning additional values, except for the status code.
*/
func (_c *Client) SubArrayRange(ctx context.Context, httpRequestBody []int, min int, max int) (httpResponseBody []int, httpStatusCode int, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/sub-array-range/{max}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`min`: min,
		`max`: max,
	})
	_in := SubArrayRangeIn{
		httpRequestBody,
		min,
		max,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	_body := httpRequestBody
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out SubArrayRangeOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out.HTTPResponseBody)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	_out.HTTPStatusCode = _httpRes.StatusCode
	httpResponseBody = _out.HTTPResponseBody
	httpStatusCode = _out.HTTPStatusCode
	return
}

// SumTwoIntegersIn are the input arguments of SumTwoIntegers.
type SumTwoIntegersIn struct {
	X int `json:"x"`
	Y int `json:"y"`
}

// SumTwoIntegersOut are the return values of SumTwoIntegers.
type SumTwoIntegersOut struct {
	Sum int `json:"sum"`
	HTTPStatusCode int `json:"-"`
}

// SumTwoIntegersResponse is the response to SumTwoIntegers.
type SumTwoIntegersResponse struct {
	data SumTwoIntegersOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SumTwoIntegersResponse) Get() (sum int, httpStatusCode int, err error) {
	sum = _out.data.Sum
	httpStatusCode = _out.data.HTTPStatusCode
	err = _out.err
	return
}

/*
SumTwoIntegers tests returning a status code from a function.
*/
func (_c *MulticastClient) SumTwoIntegers(ctx context.Context, x int, y int) <-chan *SumTwoIntegersResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/sum-two-integers`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`x`: x,
		`y`: y,
	})
	_in := SumTwoIntegersIn{
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *SumTwoIntegersResponse, cap(_ch))
	for _i := range _ch {
		var _r SumTwoIntegersResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
			_r.data.HTTPStatusCode = _httpRes.StatusCode
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
SumTwoIntegers tests returning a status code from a function.
*/
func (_c *Client) SumTwoIntegers(ctx context.Context, x int, y int) (sum int, httpStatusCode int, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/sum-two-integers`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`x`: x,
		`y`: y,
	})
	_in := SumTwoIntegersIn{
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out SumTwoIntegersOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	_out.HTTPStatusCode = _httpRes.StatusCode
	sum = _out.Sum
	httpStatusCode = _out.HTTPStatusCode
	return
}

// FunctionPathArgumentsIn are the input arguments of FunctionPathArguments.
type FunctionPathArgumentsIn struct {
	Named string `json:"named"`
	Path2 string `json:"path2"`
	Suffix string `json:"suffix"`
}

// FunctionPathArgumentsOut are the return values of FunctionPathArguments.
type FunctionPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// FunctionPathArgumentsResponse is the response to FunctionPathArguments.
type FunctionPathArgumentsResponse struct {
	data FunctionPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *FunctionPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
FunctionPathArguments tests path arguments in functions.
*/
func (_c *MulticastClient) FunctionPathArguments(ctx context.Context, named string, path2 string, suffix string) <-chan *FunctionPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := FunctionPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *FunctionPathArgumentsResponse, 1)
		_res <- &FunctionPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *FunctionPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r FunctionPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
FunctionPathArguments tests path arguments in functions.
*/
func (_c *Client) FunctionPathArguments(ctx context.Context, named string, path2 string, suffix string) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := FunctionPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out FunctionPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}

// NonStringPathArgumentsIn are the input arguments of NonStringPathArguments.
type NonStringPathArgumentsIn struct {
	Named int `json:"named"`
	Path2 bool `json:"path2"`
	Suffix float64 `json:"suffix"`
}

// NonStringPathArgumentsOut are the return values of NonStringPathArguments.
type NonStringPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// NonStringPathArgumentsResponse is the response to NonStringPathArguments.
type NonStringPathArgumentsResponse struct {
	data NonStringPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *NonStringPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
NonStringPathArguments tests path arguments that are not strings.
*/
func (_c *MulticastClient) NonStringPathArguments(ctx context.Context, named int, path2 bool, suffix float64) <-chan *NonStringPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := NonStringPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *NonStringPathArgumentsResponse, 1)
		_res <- &NonStringPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *NonStringPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r NonStringPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
NonStringPathArguments tests path arguments that are not strings.
*/
func (_c *Client) NonStringPathArguments(ctx context.Context, named int, path2 bool, suffix float64) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := NonStringPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out NonStringPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}

// UnnamedFunctionPathArgumentsIn are the input arguments of UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsIn struct {
	Path1 string `json:"path1"`
	Path2 string `json:"path2"`
	Path3 string `json:"path3"`
}

// UnnamedFunctionPathArgumentsOut are the return values of UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// UnnamedFunctionPathArgumentsResponse is the response to UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsResponse struct {
	data UnnamedFunctionPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *UnnamedFunctionPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
UnnamedFunctionPathArguments tests path arguments that are not named.
*/
func (_c *MulticastClient) UnnamedFunctionPathArguments(ctx context.Context, path1 string, path2 string, path3 string) <-chan *UnnamedFunctionPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`path1`: path1,
		`path2`: path2,
		`path3`: path3,
	})
	_in := UnnamedFunctionPathArgumentsIn{
		path1,
		path2,
		path3,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *UnnamedFunctionPathArgumentsResponse, 1)
		_res <- &UnnamedFunctionPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)

	_res := make(chan *UnnamedFunctionPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r UnnamedFunctionPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
UnnamedFunctionPathArguments tests path arguments that are not named.
*/
func (_c *Client) UnnamedFunctionPathArguments(ctx context.Context, path1 string, path2 string, path3 string) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`path1`: path1,
		`path2`: path2,
		`path3`: path3,
	})
	_in := UnnamedFunctionPathArgumentsIn{
		path1,
		path2,
		path3,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out UnnamedFunctionPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}
