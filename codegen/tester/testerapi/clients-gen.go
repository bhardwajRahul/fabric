/*
Copyright (c) 2023-2026 Microbus LLC and various contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

	http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package testerapi implements the public API of the codegen.test microservice,
including clients and data structures.

The tester is used to test the code generator's functions.
*/
package testerapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
)

// Hostname is the default hostname of the microservice: codegen.test.
const Hostname = "codegen.test"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfStringCut = httpx.JoinHostAndPath(Hostname, `:443/string-cut`)
	URLOfPointDistance = httpx.JoinHostAndPath(Hostname, `:443/point-distance`)
	URLOfShiftPoint = httpx.JoinHostAndPath(Hostname, `:443/shift-point`)
	URLOfLinesIntersection = httpx.JoinHostAndPath(Hostname, `:443/lines-intersection`)
	URLOfEchoAnything = httpx.JoinHostAndPath(Hostname, `:443/echo-anything`)
	URLOfSubArrayRange = httpx.JoinHostAndPath(Hostname, `:443/sub-array-range/{max}`)
	URLOfSumTwoIntegers = httpx.JoinHostAndPath(Hostname, `:443/sum-two-integers`)
	URLOfFunctionPathArguments = httpx.JoinHostAndPath(Hostname, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfNonStringPathArguments = httpx.JoinHostAndPath(Hostname, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfUnnamedFunctionPathArguments = httpx.JoinHostAndPath(Hostname, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	URLOfPathArgumentsPriority = httpx.JoinHostAndPath(Hostname, `:443/path-arguments-priority/{foo}`)
	URLOfWhatTimeIsIt = httpx.JoinHostAndPath(Hostname, `:443/what-time-is-it`)
	URLOfAuthzRequired = httpx.JoinHostAndPath(Hostname, `:443/authz-required`)
	URLOfEcho = httpx.JoinHostAndPath(Hostname, `:443/echo`)
	URLOfMultiValueHeaders = httpx.JoinHostAndPath(Hostname, `:443/multi-value-headers`)
	URLOfWebPathArguments = httpx.JoinHostAndPath(Hostname, `:443/web-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfUnnamedWebPathArguments = httpx.JoinHostAndPath(Hostname, `:443/unnamed-web-path-arguments/{}/foo/{}/bar/{+}`)
	URLOfDirectoryServer = httpx.JoinHostAndPath(Hostname, `:443/directory-server/{filename+}`)
	URLOfHello = httpx.JoinHostAndPath(Hostname, `:443/hello`)
)

// Client is a lightweight proxy for making unicast calls to the codegen.test microservice.
type Client struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewClient creates a new unicast client proxy to the codegen.test microservice.
func NewClient(caller service.Publisher) Client {
	return Client{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost returns a copy of the client with a different hostname to be applied to requests.
func (_c Client) ForHost(host string) Client {
	return Client{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the client with options to be applied to requests.
func (_c Client) WithOptions(opts ...pub.Option) Client {
	return Client{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// MulticastClient is a lightweight proxy for making multicast calls to the codegen.test microservice.
type MulticastClient struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewMulticastClient creates a new multicast client proxy to the codegen.test microservice.
func NewMulticastClient(caller service.Publisher) MulticastClient {
	return MulticastClient{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost returns a copy of the client with a different hostname to be applied to requests.
func (_c MulticastClient) ForHost(host string) MulticastClient {
	return MulticastClient{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the client with options to be applied to requests.
func (_c MulticastClient) WithOptions(opts ...pub.Option) MulticastClient {
	return MulticastClient{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// MulticastTrigger is a lightweight proxy for triggering the events of the codegen.test microservice.
type MulticastTrigger struct {
	svc  service.Publisher
	host string
	opts []pub.Option
}

// NewMulticastTrigger creates a new multicast trigger of events of the codegen.test microservice.
func NewMulticastTrigger(caller service.Publisher) MulticastTrigger {
	return MulticastTrigger{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost returns a copy of the trigger with a different hostname to be applied to requests.
func (_c MulticastTrigger) ForHost(host string) MulticastTrigger {
	return MulticastTrigger{
		svc:  _c.svc,
		host: host,
		opts: _c.opts,
	}
}

// WithOptions returns a copy of the trigger with options to be applied to requests.
func (_c MulticastTrigger) WithOptions(opts ...pub.Option) MulticastTrigger {
	return MulticastTrigger{
		svc:  _c.svc,
		host: _c.host,
		opts: append(_c.opts, opts...),
	}
}

// Hook assists in the subscription to the events of the codegen.test microservice.
type Hook struct {
	svc  service.Subscriber
	host string
}

// NewHook creates a new hook to the events of the codegen.test microservice.
func NewHook(listener service.Subscriber) Hook {
	return Hook{
		svc:  listener,
		host: "codegen.test",
	}
}

// ForHost returns a copy of the hook with a different hostname to be applied to the subscription.
func (_c Hook) ForHost(host string) Hook {
	return Hook{
		svc:  _c.svc,
		host: host,
	}
}

// errChan returns a response channel with a single error response.
func (_c MulticastClient) errChan(err error) <-chan *pub.Response {
	ch := make(chan *pub.Response, 1)
	ch <- pub.NewErrorResponse(err)
	close(ch)
	return ch
}

/*
Echo tests a typical web handler.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c Client) Echo(ctx context.Context, method string, relURL string, contentType string, body any) (res *http.Response, err error) {
	if method == "" {
		method = "POST"
	}
	res, err = _c.svc.Request(
		ctx,
		pub.Method(method),
		pub.URL(URLOfEcho),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
Echo tests a typical web handler.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c MulticastClient) Echo(ctx context.Context, method string, relURL string, contentType string, body any) <-chan *pub.Response {
	if method == "" {
		method = "POST"
	}
	return _c.svc.Publish(
		ctx,
		pub.Method(method),
		pub.URL(URLOfEcho),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
}

/*
MultiValueHeaders tests a passing in and returning headers with multiple values.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c Client) MultiValueHeaders(ctx context.Context, method string, relURL string, contentType string, body any) (res *http.Response, err error) {
	if method == "" {
		method = "POST"
	}
	res, err = _c.svc.Request(
		ctx,
		pub.Method(method),
		pub.URL(URLOfMultiValueHeaders),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
MultiValueHeaders tests a passing in and returning headers with multiple values.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c MulticastClient) MultiValueHeaders(ctx context.Context, method string, relURL string, contentType string, body any) <-chan *pub.Response {
	if method == "" {
		method = "POST"
	}
	return _c.svc.Publish(
		ctx,
		pub.Method(method),
		pub.URL(URLOfMultiValueHeaders),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
}

/*
WebPathArguments tests path arguments in web handlers.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c Client) WebPathArguments(ctx context.Context, method string, relURL string, contentType string, body any) (res *http.Response, err error) {
	if method == "" {
		method = "POST"
	}
	res, err = _c.svc.Request(
		ctx,
		pub.Method(method),
		pub.URL(URLOfWebPathArguments),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
WebPathArguments tests path arguments in web handlers.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c MulticastClient) WebPathArguments(ctx context.Context, method string, relURL string, contentType string, body any) <-chan *pub.Response {
	if method == "" {
		method = "POST"
	}
	return _c.svc.Publish(
		ctx,
		pub.Method(method),
		pub.URL(URLOfWebPathArguments),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
}

/*
UnnamedWebPathArguments tests path arguments that are not named.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c Client) UnnamedWebPathArguments(ctx context.Context, relURL string) (res *http.Response, err error) {
	res, err = _c.svc.Request(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfUnnamedWebPathArguments),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
UnnamedWebPathArguments tests path arguments that are not named.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c MulticastClient) UnnamedWebPathArguments(ctx context.Context, relURL string) <-chan *pub.Response {
	return _c.svc.Publish(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfUnnamedWebPathArguments),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
}

/*
DirectoryServer tests service resources given a greedy path argument.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c Client) DirectoryServer(ctx context.Context, relURL string) (res *http.Response, err error) {
	res, err = _c.svc.Request(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfDirectoryServer),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
DirectoryServer tests service resources given a greedy path argument.

If a URL is provided, it is resolved relative to the URL of the endpoint.
*/
func (_c MulticastClient) DirectoryServer(ctx context.Context, relURL string) <-chan *pub.Response {
	return _c.svc.Publish(
		ctx,
		pub.Method("GET"),
		pub.URL(URLOfDirectoryServer),
		pub.RelativeURL(relURL),
		pub.Options(_c.opts...),
	)
}

/*
Hello prints hello in the language best matching the request's Accept-Language header.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c Client) Hello(ctx context.Context, method string, relURL string, contentType string, body any) (res *http.Response, err error) {
	if method == "" {
		method = "POST"
	}
	res, err = _c.svc.Request(
		ctx,
		pub.Method(method),
		pub.URL(URLOfHello),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
	return res, err // No trace
}

/*
Hello prints hello in the language best matching the request's Accept-Language header.

If a URL is provided, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c MulticastClient) Hello(ctx context.Context, method string, relURL string, contentType string, body any) <-chan *pub.Response {
	if method == "" {
		method = "POST"
	}
	return _c.svc.Publish(
		ctx,
		pub.Method(method),
		pub.URL(URLOfHello),
		pub.RelativeURL(relURL),
		pub.ContentType(contentType),
		pub.Body(body),
		pub.Options(_c.opts...),
	)
}

// StringCutIn are the input arguments of StringCut.
type StringCutIn struct {
	S string `json:"s"`
	Sep string `json:"sep"`
}

// StringCutOut are the return values of StringCut.
type StringCutOut struct {
	Before string `json:"before"`
	After string `json:"after"`
	Found bool `json:"found"`
}

// StringCutResponse is the response to StringCut.
type StringCutResponse struct {
	data StringCutOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *StringCutResponse) Get() (before string, after string, found bool, err error) {
	before = _out.data.Before
	after = _out.data.After
	found = _out.data.Found
	err = _out.err
	return
}

/*
StringCut tests a function that takes primitive input arguments and returns primitive values.
*/
func (_c MulticastClient) StringCut(ctx context.Context, s string, sep string) <-chan *StringCutResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/string-cut`)
	_in := StringCutIn{
		s,
		sep,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *StringCutResponse, cap(_ch))
	for _i := range _ch {
		var _r StringCutResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
StringCut tests a function that takes primitive input arguments and returns primitive values.
*/
func (_c Client) StringCut(ctx context.Context, s string, sep string) (before string, after string, found bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/string-cut`)
	_in := StringCutIn{
		s,
		sep,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out StringCutOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	before = _out.Before
	after = _out.After
	found = _out.Found
	return
}

// PointDistanceIn are the input arguments of PointDistance.
type PointDistanceIn struct {
	P1 XYCoord `json:"p1"`
	P2 *XYCoord `json:"p2"`
}

// PointDistanceOut are the return values of PointDistance.
type PointDistanceOut struct {
	D float64 `json:"d"`
}

// PointDistanceResponse is the response to PointDistance.
type PointDistanceResponse struct {
	data PointDistanceOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *PointDistanceResponse) Get() (d float64, err error) {
	d = _out.data.D
	err = _out.err
	return
}

/*
PointDistance tests a function that takes non-primitive input arguments.
*/
func (_c MulticastClient) PointDistance(ctx context.Context, p1 XYCoord, p2 *XYCoord) <-chan *PointDistanceResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/point-distance`)
	_in := PointDistanceIn{
		p1,
		p2,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *PointDistanceResponse, 1)
		_res <- &PointDistanceResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *PointDistanceResponse, cap(_ch))
	for _i := range _ch {
		var _r PointDistanceResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
PointDistance tests a function that takes non-primitive input arguments.
*/
func (_c Client) PointDistance(ctx context.Context, p1 XYCoord, p2 *XYCoord) (d float64, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/point-distance`)
	_in := PointDistanceIn{
		p1,
		p2,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out PointDistanceOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	d = _out.D
	return
}

// ShiftPointIn are the input arguments of ShiftPoint.
type ShiftPointIn struct {
	P *XYCoord `json:"p"`
	X float64 `json:"x"`
	Y float64 `json:"y"`
}

// ShiftPointOut are the return values of ShiftPoint.
type ShiftPointOut struct {
	Shifted *XYCoord `json:"shifted"`
}

// ShiftPointResponse is the response to ShiftPoint.
type ShiftPointResponse struct {
	data ShiftPointOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *ShiftPointResponse) Get() (shifted *XYCoord, err error) {
	shifted = _out.data.Shifted
	err = _out.err
	return
}

/*
ShiftPoint tests passing pointers of non-primitive types.
*/
func (_c MulticastClient) ShiftPoint(ctx context.Context, p *XYCoord, x float64, y float64) <-chan *ShiftPointResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/shift-point`)
	_in := ShiftPointIn{
		p,
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *ShiftPointResponse, cap(_ch))
	for _i := range _ch {
		var _r ShiftPointResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
ShiftPoint tests passing pointers of non-primitive types.
*/
func (_c Client) ShiftPoint(ctx context.Context, p *XYCoord, x float64, y float64) (shifted *XYCoord, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/shift-point`)
	_in := ShiftPointIn{
		p,
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out ShiftPointOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	shifted = _out.Shifted
	return
}

// LinesIntersectionIn are the input arguments of LinesIntersection.
type LinesIntersectionIn struct {
	L1 XYLine `json:"l1"`
	L2 *XYLine `json:"l2"`
}

// LinesIntersectionOut are the return values of LinesIntersection.
type LinesIntersectionOut struct {
	B bool `json:"b"`
}

// LinesIntersectionResponse is the response to LinesIntersection.
type LinesIntersectionResponse struct {
	data LinesIntersectionOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *LinesIntersectionResponse) Get() (b bool, err error) {
	b = _out.data.B
	err = _out.err
	return
}

/*
LinesIntersection tests nested non-primitive types.
*/
func (_c MulticastClient) LinesIntersection(ctx context.Context, l1 XYLine, l2 *XYLine) <-chan *LinesIntersectionResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/lines-intersection`)
	_in := LinesIntersectionIn{
		l1,
		l2,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *LinesIntersectionResponse, cap(_ch))
	for _i := range _ch {
		var _r LinesIntersectionResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
LinesIntersection tests nested non-primitive types.
*/
func (_c Client) LinesIntersection(ctx context.Context, l1 XYLine, l2 *XYLine) (b bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/lines-intersection`)
	_in := LinesIntersectionIn{
		l1,
		l2,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out LinesIntersectionOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	b = _out.B
	return
}

// EchoAnythingIn are the input arguments of EchoAnything.
type EchoAnythingIn struct {
	Original any `json:"original"`
}

// EchoAnythingOut are the return values of EchoAnything.
type EchoAnythingOut struct {
	Echoed any `json:"echoed"`
}

// EchoAnythingResponse is the response to EchoAnything.
type EchoAnythingResponse struct {
	data EchoAnythingOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *EchoAnythingResponse) Get() (echoed any, err error) {
	echoed = _out.data.Echoed
	err = _out.err
	return
}

/*
EchoAnything tests arguments of type any.
*/
func (_c MulticastClient) EchoAnything(ctx context.Context, original any) <-chan *EchoAnythingResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/echo-anything`)
	_in := EchoAnythingIn{
		original,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *EchoAnythingResponse, cap(_ch))
	for _i := range _ch {
		var _r EchoAnythingResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
EchoAnything tests arguments of type any.
*/
func (_c Client) EchoAnything(ctx context.Context, original any) (echoed any, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/echo-anything`)
	_in := EchoAnythingIn{
		original,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out EchoAnythingOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	echoed = _out.Echoed
	return
}

// SubArrayRangeIn are the input arguments of SubArrayRange.
type SubArrayRangeIn struct {
	HTTPRequestBody []int `json:"-"`
	Min int `json:"min"`
	Max int `json:"max"`
}

// SubArrayRangeOut are the return values of SubArrayRange.
type SubArrayRangeOut struct {
	HTTPResponseBody []int `json:"httpResponseBody"`
	HTTPStatusCode int `json:"-"`
}

// SubArrayRangeResponse is the response to SubArrayRange.
type SubArrayRangeResponse struct {
	data SubArrayRangeOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SubArrayRangeResponse) Get() (httpResponseBody []int, httpStatusCode int, err error) {
	httpResponseBody = _out.data.HTTPResponseBody
	httpStatusCode = _out.data.HTTPStatusCode
	err = _out.err
	return
}

/*
SubArrayRange tests sending arguments as the entire request and response bodies.
An httpRequestBody argument allows sending other arguments via query or path.
An httpResponseBody argument prevents returning additional values, except for the status code.
*/
func (_c MulticastClient) SubArrayRange(ctx context.Context, httpRequestBody []int, min int, max int) <-chan *SubArrayRangeResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/sub-array-range/{max}`)
	_in := SubArrayRangeIn{
		httpRequestBody,
		min,
		max,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *SubArrayRangeResponse, 1)
		_res <- &SubArrayRangeResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	_body := httpRequestBody
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *SubArrayRangeResponse, cap(_ch))
	for _i := range _ch {
		var _r SubArrayRangeResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data.HTTPResponseBody))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
			_r.data.HTTPStatusCode = _httpRes.StatusCode
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
SubArrayRange tests sending arguments as the entire request and response bodies.
An httpRequestBody argument allows sending other arguments via query or path.
An httpResponseBody argument prevents returning additional values, except for the status code.
*/
func (_c Client) SubArrayRange(ctx context.Context, httpRequestBody []int, min int, max int) (httpResponseBody []int, httpStatusCode int, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/sub-array-range/{max}`)
	_in := SubArrayRangeIn{
		httpRequestBody,
		min,
		max,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	_body := httpRequestBody
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out SubArrayRangeOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out.HTTPResponseBody)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	_out.HTTPStatusCode = _httpRes.StatusCode
	httpResponseBody = _out.HTTPResponseBody
	httpStatusCode = _out.HTTPStatusCode
	return
}

// SumTwoIntegersIn are the input arguments of SumTwoIntegers.
type SumTwoIntegersIn struct {
	X int `json:"x"`
	Y int `json:"y"`
}

// SumTwoIntegersOut are the return values of SumTwoIntegers.
type SumTwoIntegersOut struct {
	Sum int `json:"sum"`
	HTTPStatusCode int `json:"-"`
}

// SumTwoIntegersResponse is the response to SumTwoIntegers.
type SumTwoIntegersResponse struct {
	data SumTwoIntegersOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SumTwoIntegersResponse) Get() (sum int, httpStatusCode int, err error) {
	sum = _out.data.Sum
	httpStatusCode = _out.data.HTTPStatusCode
	err = _out.err
	return
}

/*
SumTwoIntegers tests returning a status code from a function.
*/
func (_c MulticastClient) SumTwoIntegers(ctx context.Context, x int, y int) <-chan *SumTwoIntegersResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/sum-two-integers`)
	_in := SumTwoIntegersIn{
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *SumTwoIntegersResponse, cap(_ch))
	for _i := range _ch {
		var _r SumTwoIntegersResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
			_r.data.HTTPStatusCode = _httpRes.StatusCode
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
SumTwoIntegers tests returning a status code from a function.
*/
func (_c Client) SumTwoIntegers(ctx context.Context, x int, y int) (sum int, httpStatusCode int, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/sum-two-integers`)
	_in := SumTwoIntegersIn{
		x,
		y,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out SumTwoIntegersOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	_out.HTTPStatusCode = _httpRes.StatusCode
	sum = _out.Sum
	httpStatusCode = _out.HTTPStatusCode
	return
}

// FunctionPathArgumentsIn are the input arguments of FunctionPathArguments.
type FunctionPathArgumentsIn struct {
	Named string `json:"named"`
	Path2 string `json:"path2"`
	Suffix string `json:"suffix"`
}

// FunctionPathArgumentsOut are the return values of FunctionPathArguments.
type FunctionPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// FunctionPathArgumentsResponse is the response to FunctionPathArguments.
type FunctionPathArgumentsResponse struct {
	data FunctionPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *FunctionPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
FunctionPathArguments tests path arguments in functions.
*/
func (_c MulticastClient) FunctionPathArguments(ctx context.Context, named string, path2 string, suffix string) <-chan *FunctionPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	_in := FunctionPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *FunctionPathArgumentsResponse, 1)
		_res <- &FunctionPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *FunctionPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r FunctionPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
FunctionPathArguments tests path arguments in functions.
*/
func (_c Client) FunctionPathArguments(ctx context.Context, named string, path2 string, suffix string) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	_in := FunctionPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out FunctionPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}

// NonStringPathArgumentsIn are the input arguments of NonStringPathArguments.
type NonStringPathArgumentsIn struct {
	Named int `json:"named"`
	Path2 bool `json:"path2"`
	Suffix float64 `json:"suffix"`
}

// NonStringPathArgumentsOut are the return values of NonStringPathArguments.
type NonStringPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// NonStringPathArgumentsResponse is the response to NonStringPathArguments.
type NonStringPathArgumentsResponse struct {
	data NonStringPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *NonStringPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
NonStringPathArguments tests path arguments that are not strings.
*/
func (_c MulticastClient) NonStringPathArguments(ctx context.Context, named int, path2 bool, suffix float64) <-chan *NonStringPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	_in := NonStringPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *NonStringPathArgumentsResponse, 1)
		_res <- &NonStringPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *NonStringPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r NonStringPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
NonStringPathArguments tests path arguments that are not strings.
*/
func (_c Client) NonStringPathArguments(ctx context.Context, named int, path2 bool, suffix float64) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/non-string-path-arguments/fixed/{named}/{}/{suffix+}`)
	_in := NonStringPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out NonStringPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}

// UnnamedFunctionPathArgumentsIn are the input arguments of UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsIn struct {
	Path1 string `json:"path1"`
	Path2 string `json:"path2"`
	Path3 string `json:"path3"`
}

// UnnamedFunctionPathArgumentsOut are the return values of UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// UnnamedFunctionPathArgumentsResponse is the response to UnnamedFunctionPathArguments.
type UnnamedFunctionPathArgumentsResponse struct {
	data UnnamedFunctionPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *UnnamedFunctionPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
UnnamedFunctionPathArguments tests path arguments that are not named.
*/
func (_c MulticastClient) UnnamedFunctionPathArguments(ctx context.Context, path1 string, path2 string, path3 string) <-chan *UnnamedFunctionPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	_in := UnnamedFunctionPathArgumentsIn{
		path1,
		path2,
		path3,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *UnnamedFunctionPathArgumentsResponse, 1)
		_res <- &UnnamedFunctionPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *UnnamedFunctionPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r UnnamedFunctionPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
UnnamedFunctionPathArguments tests path arguments that are not named.
*/
func (_c Client) UnnamedFunctionPathArguments(ctx context.Context, path1 string, path2 string, path3 string) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/unnamed-function-path-arguments/{}/foo/{}/bar/{+}`)
	_in := UnnamedFunctionPathArgumentsIn{
		path1,
		path2,
		path3,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out UnnamedFunctionPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}

// PathArgumentsPriorityIn are the input arguments of PathArgumentsPriority.
type PathArgumentsPriorityIn struct {
	Foo string `json:"foo"`
}

// PathArgumentsPriorityOut are the return values of PathArgumentsPriority.
type PathArgumentsPriorityOut struct {
	Echo string `json:"echo"`
}

// PathArgumentsPriorityResponse is the response to PathArgumentsPriority.
type PathArgumentsPriorityResponse struct {
	data PathArgumentsPriorityOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *PathArgumentsPriorityResponse) Get() (echo string, err error) {
	echo = _out.data.Echo
	err = _out.err
	return
}

/*
PathArgumentsPriority tests the priority of path arguments in functions.
*/
func (_c MulticastClient) PathArgumentsPriority(ctx context.Context, foo string) <-chan *PathArgumentsPriorityResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/path-arguments-priority/{foo}`)
	_in := PathArgumentsPriorityIn{
		foo,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *PathArgumentsPriorityResponse, cap(_ch))
	for _i := range _ch {
		var _r PathArgumentsPriorityResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
PathArgumentsPriority tests the priority of path arguments in functions.
*/
func (_c Client) PathArgumentsPriority(ctx context.Context, foo string) (echo string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/path-arguments-priority/{foo}`)
	_in := PathArgumentsPriorityIn{
		foo,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out PathArgumentsPriorityOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	echo = _out.Echo
	return
}

// WhatTimeIsItIn are the input arguments of WhatTimeIsIt.
type WhatTimeIsItIn struct {
}

// WhatTimeIsItOut are the return values of WhatTimeIsIt.
type WhatTimeIsItOut struct {
	T time.Time `json:"t"`
}

// WhatTimeIsItResponse is the response to WhatTimeIsIt.
type WhatTimeIsItResponse struct {
	data WhatTimeIsItOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *WhatTimeIsItResponse) Get() (t time.Time, err error) {
	t = _out.data.T
	err = _out.err
	return
}

/*
WhatTimeIsIt tests shifting the clock.
*/
func (_c MulticastClient) WhatTimeIsIt(ctx context.Context) <-chan *WhatTimeIsItResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/what-time-is-it`)
	_in := WhatTimeIsItIn{
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *WhatTimeIsItResponse, cap(_ch))
	for _i := range _ch {
		var _r WhatTimeIsItResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
WhatTimeIsIt tests shifting the clock.
*/
func (_c Client) WhatTimeIsIt(ctx context.Context) (t time.Time, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/what-time-is-it`)
	_in := WhatTimeIsItIn{
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out WhatTimeIsItOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	t = _out.T
	return
}

// AuthzRequiredIn are the input arguments of AuthzRequired.
type AuthzRequiredIn struct {
}

// AuthzRequiredOut are the return values of AuthzRequired.
type AuthzRequiredOut struct {
}

// AuthzRequiredResponse is the response to AuthzRequired.
type AuthzRequiredResponse struct {
	data AuthzRequiredOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *AuthzRequiredResponse) Get() (err error) {
	err = _out.err
	return
}

/*
AuthzRequired tests authorization.
*/
func (_c MulticastClient) AuthzRequired(ctx context.Context) <-chan *AuthzRequiredResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/authz-required`)
	_in := AuthzRequiredIn{
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *AuthzRequiredResponse, cap(_ch))
	for _i := range _ch {
		var _r AuthzRequiredResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
AuthzRequired tests authorization.
*/
func (_c Client) AuthzRequired(ctx context.Context) (err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/authz-required`)
	_in := AuthzRequiredIn{
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out AuthzRequiredOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	return
}

// OnDiscoveredIn are the input arguments of OnDiscovered.
type OnDiscoveredIn struct {
	P XYCoord `json:"p"`
	N int `json:"n"`
}

// OnDiscoveredOut are the return values of OnDiscovered.
type OnDiscoveredOut struct {
	Q XYCoord `json:"q"`
	M int `json:"m"`
}

// OnDiscoveredResponse is the response to OnDiscovered.
type OnDiscoveredResponse struct {
	data OnDiscoveredOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *OnDiscoveredResponse) Get() (q XYCoord, m int, err error) {
	q = _out.data.Q
	m = _out.data.M
	err = _out.err
	return
}

/*
OnDiscovered tests firing events.
*/
func (_c MulticastTrigger) OnDiscovered(ctx context.Context, p XYCoord, n int) <-chan *OnDiscoveredResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:417/on-discovered`)
	_in := OnDiscoveredIn{
		p,
		n,
	}
	var _query url.Values
	_body := _in
	_ch := _c.svc.Publish(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
		pub.Options(_c.opts...),
	)

	_res := make(chan *OnDiscoveredResponse, cap(_ch))
	for _i := range _ch {
		var _r OnDiscoveredResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
OnDiscovered tests firing events.
*/
func (_c Hook) OnDiscovered(handler func(ctx context.Context, p XYCoord, n int) (q XYCoord, m int, err error)) (err error) {
	doOnDiscovered := func(w http.ResponseWriter, r *http.Request) error {
		var i OnDiscoveredIn
		var o OnDiscoveredOut
		err = httpx.ParseRequest(r, `:417/on-discovered`, &i, &i, &i)
		if err != nil {
			return errors.Trace(err)
		}
		o.Q, o.M, err = handler(
			r.Context(),
			i.P,
			i.N,
		)
		if err != nil {
			return err // No trace
		}
		w.Header().Set("Content-Type", "application/json")
		encoder := json.NewEncoder(w)
		err = encoder.Encode(o)
		if err != nil {
			return errors.Trace(err)
		}
		return nil
	}
	path := httpx.JoinHostAndPath(_c.host, `:417/on-discovered`)
	if handler == nil {
		return _c.svc.Unsubscribe(`POST`, path)
	}
	return _c.svc.Subscribe(`POST`, path, doOnDiscovered)
}
