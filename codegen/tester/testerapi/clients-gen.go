/*
Copyright (c) 2023-2024 Microbus LLC and various contributors

This file and the project encapsulating it are the confidential intellectual property of Microbus LLC.
Neither may be used, copied or distributed without the express written consent of Microbus LLC.
*/

// Code generated by Microbus. DO NOT EDIT.

/*
Package testerapi implements the public API of the codegen.test microservice,
including clients and data structures.

The tester is used to test the code generator's functions.
*/
package testerapi

import (
	"context"
	"encoding/json"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/pub"
	"github.com/microbus-io/fabric/service"
	"github.com/microbus-io/fabric/sub"
)

var (
	_ context.Context
	_ *json.Decoder
	_ io.Reader
	_ *http.Request
	_ *url.URL
	_ strings.Reader
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.BodyReader
	_ pub.Option
	_ sub.Option
)

// Hostname is the default hostname of the microservice: codegen.test.
const Hostname = "codegen.test"

// Fully-qualified URLs of the microservice's endpoints.
var (
	URLOfStringCut = httpx.JoinHostAndPath(Hostname, `:443/string-cut`)
	URLOfPointDistance = httpx.JoinHostAndPath(Hostname, `:443/point-distance`)
	URLOfSubArrayRange = httpx.JoinHostAndPath(Hostname, `:443/sub-array-range/{max}`)
	URLOfFunctionPathArguments = httpx.JoinHostAndPath(Hostname, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	URLOfWebPathArguments = httpx.JoinHostAndPath(Hostname, `:443/web-path-arguments/fixed/{named}/{}/{suffix+}`)
)

// Client is an interface to calling the endpoints of the codegen.test microservice.
// This simple version is for unicast calls.
type Client struct {
	svc  service.Publisher
	host string
}

// NewClient creates a new unicast client to the codegen.test microservice.
func NewClient(caller service.Publisher) *Client {
	return &Client{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *Client) ForHost(host string) *Client {
	_c.host = host
	return _c
}

// MulticastClient is an interface to calling the endpoints of the codegen.test microservice.
// This advanced version is for multicast calls.
type MulticastClient struct {
	svc  service.Publisher
	host string
}

// NewMulticastClient creates a new multicast client to the codegen.test microservice.
func NewMulticastClient(caller service.Publisher) *MulticastClient {
	return &MulticastClient{
		svc:  caller,
		host: "codegen.test",
	}
}

// ForHost replaces the default hostname of this client.
func (_c *MulticastClient) ForHost(host string) *MulticastClient {
	_c.host = host
	return _c
}

// errChan returns a response channel with a single error response.
func (_c *MulticastClient) errChan(err error) <-chan *pub.Response {
	ch := make(chan *pub.Response, 1)
	ch <- pub.NewErrorResponse(err)
	close(ch)
	return ch
}

/*
WebPathArguments_Get performs a GET request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) WebPathArguments_Get(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("GET"), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments_Get performs a GET request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) WebPathArguments_Get(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("GET"), pub.URL(url))
}

/*
WebPathArguments_Post performs a POST request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) WebPathArguments_Post(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments_Post performs a POST request to the WebPathArguments endpoint.

WebPathArguments tests path arguments in web handlers.

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) WebPathArguments_Post(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = httpx.ResolveURL(URLOfWebPathArguments, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

/*
WebPathArguments tests path arguments in web handlers.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) WebPathArguments(ctx context.Context, r *http.Request) (res *http.Response, err error) {
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := httpx.ResolveURL(URLOfWebPathArguments, r.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
WebPathArguments tests path arguments in web handlers.

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) WebPathArguments(ctx context.Context, r *http.Request) <-chan *pub.Response {
	var err error
	if r == nil {
		r, err = http.NewRequest(`GET`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := httpx.ResolveURL(URLOfWebPathArguments, r.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	url, err = httpx.ResolvePathArguments(url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(r.Method), pub.URL(url), pub.CopyHeaders(r.Header), pub.Body(r.Body))
}

// StringCutIn are the input arguments of StringCut.
type StringCutIn struct {
	S string `json:"s"`
	Sep string `json:"sep"`
}

// StringCutOut are the return values of StringCut.
type StringCutOut struct {
	Before string `json:"before"`
	After string `json:"after"`
	Found bool `json:"found"`
}

// StringCutResponse is the response to StringCut.
type StringCutResponse struct {
	data StringCutOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *StringCutResponse) Get() (before string, after string, found bool, err error) {
	before = _out.data.Before
	after = _out.data.After
	found = _out.data.Found
	err = _out.err
	return
}

/*
StringCut tests a standard function that takes multiple input arguments and returns multiple values.
*/
func (_c *MulticastClient) StringCut(ctx context.Context, s string, sep string, _options ...pub.Option) <-chan *StringCutResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/string-cut`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`s`: s,
		`sep`: sep,
	})
	_in := StringCutIn{
		s,
		sep,
	}
	var _query url.Values
	_body := _in
	_opts := []pub.Option{
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	}
	_opts = append(_opts, _options...)
	_ch := _c.svc.Publish(ctx, _opts...)

	_res := make(chan *StringCutResponse, cap(_ch))
	for _i := range _ch {
		var _r StringCutResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
StringCut tests a standard function that takes multiple input arguments and returns multiple values.
*/
func (_c *Client) StringCut(ctx context.Context, s string, sep string) (before string, after string, found bool, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/string-cut`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`s`: s,
		`sep`: sep,
	})
	_in := StringCutIn{
		s,
		sep,
	}
	var _query url.Values
	_body := _in
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out StringCutOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	before = _out.Before
	after = _out.After
	found = _out.Found
	return
}

// PointDistanceIn are the input arguments of PointDistance.
type PointDistanceIn struct {
	P1 XYCoord `json:"p1"`
	P2 XYCoord `json:"p2"`
}

// PointDistanceOut are the return values of PointDistance.
type PointDistanceOut struct {
	D float64 `json:"d"`
}

// PointDistanceResponse is the response to PointDistance.
type PointDistanceResponse struct {
	data PointDistanceOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *PointDistanceResponse) Get() (d float64, err error) {
	d = _out.data.D
	err = _out.err
	return
}

/*
PointDistance tests passing non-primitive types via query arguments.
*/
func (_c *MulticastClient) PointDistance(ctx context.Context, p1 XYCoord, p2 XYCoord, _options ...pub.Option) <-chan *PointDistanceResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/point-distance`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`p1`: p1,
		`p2`: p2,
	})
	_in := PointDistanceIn{
		p1,
		p2,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *PointDistanceResponse, 1)
		_res <- &PointDistanceResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_opts := []pub.Option{
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	}
	_opts = append(_opts, _options...)
	_ch := _c.svc.Publish(ctx, _opts...)

	_res := make(chan *PointDistanceResponse, cap(_ch))
	for _i := range _ch {
		var _r PointDistanceResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
PointDistance tests passing non-primitive types via query arguments.
*/
func (_c *Client) PointDistance(ctx context.Context, p1 XYCoord, p2 XYCoord) (d float64, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/point-distance`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`p1`: p1,
		`p2`: p2,
	})
	_in := PointDistanceIn{
		p1,
		p2,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out PointDistanceOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	d = _out.D
	return
}

// SubArrayRangeIn are the input arguments of SubArrayRange.
type SubArrayRangeIn struct {
	HTTPRequestBody []int `json:"-"`
	Min int `json:"min"`
	Max int `json:"max"`
}

// SubArrayRangeOut are the return values of SubArrayRange.
type SubArrayRangeOut struct {
	HTTPResponseBody []int `json:"httpResponseBody"`
	Sum int `json:"sum"`
	HTTPStatusCode int `json:"-"`
}

// SubArrayRangeResponse is the response to SubArrayRange.
type SubArrayRangeResponse struct {
	data SubArrayRangeOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *SubArrayRangeResponse) Get() (httpResponseBody []int, sum int, httpStatusCode int, err error) {
	httpResponseBody = _out.data.HTTPResponseBody
	sum = _out.data.Sum
	httpStatusCode = _out.data.HTTPStatusCode
	err = _out.err
	return
}

/*
SubArrayRange tests sending arguments as the entire request and response bodies.
An httpRequestBody argument allows sending other arguments via query or path.
An httpResponseBody argument prevents returning additional values, except for the status code.
*/
func (_c *MulticastClient) SubArrayRange(ctx context.Context, httpRequestBody []int, min int, max int, _options ...pub.Option) <-chan *SubArrayRangeResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/sub-array-range/{max}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`min`: min,
		`max`: max,
	})
	_in := SubArrayRangeIn{
		httpRequestBody,
		min,
		max,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *SubArrayRangeResponse, 1)
		_res <- &SubArrayRangeResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	_body := httpRequestBody
	_opts := []pub.Option{
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	}
	_opts = append(_opts, _options...)
	_ch := _c.svc.Publish(ctx, _opts...)

	_res := make(chan *SubArrayRangeResponse, cap(_ch))
	for _i := range _ch {
		var _r SubArrayRangeResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data.HTTPResponseBody))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
			_r.data.HTTPStatusCode = _httpRes.StatusCode
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
SubArrayRange tests sending arguments as the entire request and response bodies.
An httpRequestBody argument allows sending other arguments via query or path.
An httpResponseBody argument prevents returning additional values, except for the status code.
*/
func (_c *Client) SubArrayRange(ctx context.Context, httpRequestBody []int, min int, max int) (httpResponseBody []int, sum int, httpStatusCode int, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/sub-array-range/{max}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`min`: min,
		`max`: max,
	})
	_in := SubArrayRangeIn{
		httpRequestBody,
		min,
		max,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	_body := httpRequestBody
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`POST`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out SubArrayRangeOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out.HTTPResponseBody)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	_out.HTTPStatusCode = _httpRes.StatusCode
	httpResponseBody = _out.HTTPResponseBody
	sum = _out.Sum
	httpStatusCode = _out.HTTPStatusCode
	return
}

// FunctionPathArgumentsIn are the input arguments of FunctionPathArguments.
type FunctionPathArgumentsIn struct {
	Named string `json:"named"`
	Path2 string `json:"path2"`
	Suffix string `json:"suffix"`
}

// FunctionPathArgumentsOut are the return values of FunctionPathArguments.
type FunctionPathArgumentsOut struct {
	Joined string `json:"joined"`
}

// FunctionPathArgumentsResponse is the response to FunctionPathArguments.
type FunctionPathArgumentsResponse struct {
	data FunctionPathArgumentsOut
	HTTPResponse *http.Response
	err error
}

// Get retrieves the return values.
func (_out *FunctionPathArgumentsResponse) Get() (joined string, err error) {
	joined = _out.data.Joined
	err = _out.err
	return
}

/*
FunctionPathArguments tests path arguments in functions.
*/
func (_c *MulticastClient) FunctionPathArguments(ctx context.Context, named string, path2 string, suffix string, _options ...pub.Option) <-chan *FunctionPathArgumentsResponse {
	_url := httpx.JoinHostAndPath(_c.host, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := FunctionPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		_res := make(chan *FunctionPathArgumentsResponse, 1)
		_res <- &FunctionPathArgumentsResponse{err: _err} // No trace
		close(_res)
		return _res
	}
	var _body any
	_opts := []pub.Option{
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	}
	_opts = append(_opts, _options...)
	_ch := _c.svc.Publish(ctx, _opts...)

	_res := make(chan *FunctionPathArgumentsResponse, cap(_ch))
	for _i := range _ch {
		var _r FunctionPathArgumentsResponse
		_httpRes, _err := _i.Get()
		_r.HTTPResponse = _httpRes
		if _err != nil {
			_r.err = _err // No trace
		} else {
			_err = json.NewDecoder(_httpRes.Body).Decode(&(_r.data))
			if _err != nil {
				_r.err = errors.Trace(_err)
			}
		}
		_res <- &_r
	}
	close(_res)
	return _res
}

/*
FunctionPathArguments tests path arguments in functions.
*/
func (_c *Client) FunctionPathArguments(ctx context.Context, named string, path2 string, suffix string) (joined string, err error) {
	var _err error
	_url := httpx.JoinHostAndPath(_c.host, `:443/function-path-arguments/fixed/{named}/{}/{suffix+}`)
	_url = httpx.InjectPathArguments(_url, map[string]any{
		`named`: named,
		`path2`: path2,
		`suffix`: suffix,
	})
	_in := FunctionPathArgumentsIn{
		named,
		path2,
		suffix,
	}
	_query, _err := httpx.EncodeDeepObject(_in)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _body any
	_httpRes, _err := _c.svc.Request(
		ctx,
		pub.Method(`GET`),
		pub.URL(_url),
		pub.Query(_query),
		pub.Body(_body),
	)
	if _err != nil {
		err = _err // No trace
		return
	}
	var _out FunctionPathArgumentsOut
	_err = json.NewDecoder(_httpRes.Body).Decode(&_out)
	if _err != nil {
		err = errors.Trace(_err)
		return
	}
	joined = _out.Joined
	return
}
