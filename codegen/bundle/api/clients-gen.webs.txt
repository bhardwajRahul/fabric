{{ if .Webs }}
// resolveURL resolves a URL in relation to the endpoint's base path.
func (_c *Client) resolveURL(base string, relative string) (resolved string, err error) {
	if relative == "" {
		return base, nil
	}
	baseURL, err := url.Parse(base)
	if err != nil {
		return "", errors.Trace(err)
	}
	relativeURL, err := url.Parse(relative)
	if err != nil {
		return "", errors.Trace(err)
	}
	resolvedURL := baseURL.ResolveReference(relativeURL)
	return resolvedURL.String(), nil
}

// resolveURL resolves a URL in relation to the endpoint's base path.
func (_c *MulticastClient) resolveURL(base string, relative string) (resolved string, err error) {
	if relative == "" {
		return base, nil
	}
	baseURL, err := url.Parse(base)
	if err != nil {
		return "", errors.Trace(err)
	}
	relativeURL, err := url.Parse(relative)
	if err != nil {
		return "", errors.Trace(err)
	}
	resolvedURL := baseURL.ResolveReference(relativeURL)
	return resolvedURL.String(), nil
}

// errChan returns a response channel with a single error response.
func (_c *MulticastClient) errChan(err error) <-chan *pub.Response {
	ch := make(chan *pub.Response, 1)
	ch <- pub.NewErrorResponse(err)
	close(ch)
	return ch
}
{{ end }}

{{- range .Webs }}

{{- if eq .Method "*" }}
/*
{{ .Name }}Get performs a GET request to the {{ .Name }} endpoint.

{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) {{ .Name }}Get(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = _c.resolveURL(URLOf{{ .Name }}, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("GET"), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
{{ .Name }}Get performs a GET request to the {{ .Name }} endpoint.

{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) {{ .Name }}Get(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = _c.resolveURL(URLOf{{ .Name }}, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("GET"), pub.URL(url))
}

/*
{{ .Name }}Post performs a POST request to the {{ .Name }} endpoint.

{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) {{ .Name }}Post(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = _c.resolveURL(URLOf{{ .Name }}, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
{{ .Name }}Post performs a POST request to the {{ .Name }} endpoint.

{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) {{ .Name }}Post(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = _c.resolveURL(URLOf{{ .Name }}, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method("POST"), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

{{- else if .MethodWithBody }}
/*
{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *Client) {{ .Name }}(ctx context.Context, url string, contentType string, body any) (res *http.Response, err error) {
	url, err = _c.resolveURL(URLOf{{ .Name }}, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(`{{ .Method }}`), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func (_c *MulticastClient) {{ .Name }}(ctx context.Context, url string, contentType string, body any) <-chan *pub.Response {
	var err error
	url, err = _c.resolveURL(URLOf{{ .Name }}, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(`{{ .Method }}`), pub.URL(url), pub.ContentType(contentType), pub.Body(body))
}

{{- else }}
/*
{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) {{ .Name }}(ctx context.Context, url string) (res *http.Response, err error) {
	url, err = _c.resolveURL(URLOf{{ .Name }}, url)
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(`{{ .Method }}`), pub.URL(url))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) {{ .Name }}(ctx context.Context, url string) <-chan *pub.Response {
	var err error
	url, err = _c.resolveURL(URLOf{{ .Name }}, url)
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(`{{ .Method }}`), pub.URL(url))
}

{{- end }}

/*
{{ if ne .Method "*" }}{{ .Name }}Any performs a customized request to the {{ .Name }} endpoint.

{{ end -}}

{{ .Description }}

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *Client) {{ .Name }}{{ if ne .Method "*" }}Any{{ end }}(ctx context.Context, httpReq *http.Request) (res *http.Response, err error) {
	if httpReq == nil {
		httpReq, err = http.NewRequest(`{{ if eq .Method "*" }}GET{{ else }}{{ .Method }}{{ end }}`, "", nil)
		if err != nil {
			return nil, errors.Trace(err)
		}
	}
	url, err := _c.resolveURL(URLOf{{ .Name }}, httpReq.URL.String())
	if err != nil {
		return nil, errors.Trace(err)
	}
	res, err = _c.svc.Request(ctx, pub.Method(httpReq.Method), pub.URL(url), pub.CopyHeaders(httpReq), pub.Body(httpReq.Body))
	if err != nil {
		return nil, err // No trace
	}
	return res, err
}

/*
{{ if ne .Method "*" }}{{ .Name }}Any performs a customized request to the {{ .Name }} endpoint.

{{ end -}}

{{ .Description }}

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func (_c *MulticastClient) {{ .Name }}{{ if ne .Method "*" }}Any{{ end }}(ctx context.Context, httpReq *http.Request) <-chan *pub.Response {
	var err error
	if httpReq == nil {
		httpReq, err = http.NewRequest(`{{ if eq .Method "*" }}GET{{ else }}{{ .Method }}{{ end }}`, "", nil)
		if err != nil {
			return _c.errChan(errors.Trace(err))
		}
	}
	url, err := _c.resolveURL(URLOf{{ .Name }}, httpReq.URL.String())
	if err != nil {
		return _c.errChan(errors.Trace(err))
	}
	return _c.svc.Publish(ctx, pub.Method(httpReq.Method), pub.URL(url), pub.CopyHeaders(httpReq), pub.Body(httpReq.Body))
}
{{ end }}