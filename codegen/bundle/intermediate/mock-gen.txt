// Code generated by Microbus. DO NOT EDIT.

package intermediate

import (
	"context"
	"encoding/json"
	"net/http"
	"time"

	"github.com/microbus-io/fabric/connector"
	"github.com/microbus-io/fabric/errors"
	"github.com/microbus-io/fabric/httpx"
	"github.com/microbus-io/fabric/sub"

	"{{ .Package }}/{{ .PackageSuffix }}api"

	{{- if .Sinks }}
	{{ range $i, $s := .Sinks }}
	{{ .SourceSuffix }}api{{ Add $i 1 }} "{{ .Source }}/{{ .SourceSuffix }}api"
	{{- end}}{{end}}
)

var (
	_ context.Context
	_ *json.Decoder
	_ *http.Request
	_ time.Duration
	_ *errors.TracedError
	_ *httpx.ResponseRecorder
	_ sub.Option
	_ {{ .PackageSuffix }}api.Client
)

// Mock is a mockable version of the {{ .General.Host }} microservice, allowing functions, event sinks and web handlers to be mocked.
type Mock struct {
	*connector.Connector

	{{- range (JoinHandlers .Functions .Sinks)}}
	mock{{ .Name }} func({{ .In }}) ({{ .Out }})
	{{- end}}

	{{- range .Webs}}
	mock{{ .Name }} func(w http.ResponseWriter, r *http.Request) (err error)
	{{- end}}
}

// NewMock creates a new mockable version of the microservice.
func NewMock() *Mock {
	svc := &Mock{
		Connector: connector.New("{{ .General.Host }}"),
	}
	svc.SetVersion(7357) // Stands for TEST
	svc.SetDescription(`{{ .General.Description }}`)
	svc.SetOnStartup(func(ctx context.Context) (err error) {
		{{- if .Functions }}
		// Functions
		{{- range .Functions }}
		svc.Subscribe(`{{ .Method }}`, `{{ .Path }}`, svc.do{{ .Name }} {{- if eq .Queue "none"}}, sub.NoQueue(){{end -}} )
		{{- end }}{{ end }}

		{{- if .Webs }}
		// Webs
		{{- range .Webs }}
		svc.Subscribe(`{{ .Method }}`, `{{ .Path }}`, svc.do{{ .Name }} {{- if eq .Queue "none" }}, sub.NoQueue(){{ end -}} )
		{{- end }}{{ end }}

		{{- if .Sinks }}
		// Sinks
		{{- range $i, $s := .Sinks }}
		{{ .SourceSuffix }}api{{ Add $i 1 }}.NewHook(svc).
		{{- if .ForHost }}ForHost(`{{ .ForHost }}`).{{ end }}
		{{- .Event }}(svc.do{{ .Name }}
		{{- if eq .Queue "none"}}, sub.NoQueue(){{ end -}}
		)
		{{- end }}{{ end }}
		return nil
	})
	svc.SetOnStartup(svc.doOnStartup)
	return svc
}

// doOnStartup makes sure that the mock is not executed in a non-dev environment.
func (svc *Mock) doOnStartup(ctx context.Context) (err error) {
	if svc.Deployment() != connector.LOCAL && svc.Deployment() != connector.TESTING {
		return errors.Newf("mocking disallowed in '%s' deployment", svc.Deployment())
	}
	return nil
}
{{/**/}}

{{- $shortPackage := .PackageSuffix }}
{{- range .Functions }}
// do{{ .Name }} handles marshaling for the {{ .Name }} function.
func (svc *Mock) do{{ .Name }}(w http.ResponseWriter, r *http.Request) error {
	if svc.mock{{ .Name }} == nil {
		return errors.New("mocked endpoint '{{ .Name }}' not implemented")
	}
	var i {{ $shortPackage }}api.{{ .Name }}In
	var o {{ $shortPackage }}api.{{ .Name }}Out
	{{- if .Signature.InputArg "httpRequestBody" }}
	err := httpx.ParseRequestBody(r, &i.{{ CapitalizeIdentifier "httpRequestBody" }})
	if err != nil {
		return errors.Trace(err)
	}
	err = httpx.DecodeDeepObject(r.URL.Query(), &i)
	if err != nil {
		return errors.Trace(err)
	}
	{{- else }}
	err := httpx.ParseRequestData(r, &i)
	if err != nil {
		return errors.Trace(err)
	}
	{{- end }}
	{{ range .Signature.OutputArgs }}o.{{ CapitalizeIdentifier .Name }}, {{ end }}err = svc.mock{{ .Name }}(
		r.Context(),
		{{- range .Signature.InputArgs }}
		i.{{ CapitalizeIdentifier .Name }},
		{{- end}}
	)
	if err != nil {
		return err // No trace
	}
	w.Header().Set("Content-Type", "application/json")
	{{- if .Signature.OutputArg "httpStatusCode" }}
	w.WriteHeader(o.{{ CapitalizeIdentifier "httpStatusCode" }})
	{{- end}}
	encoder := json.NewEncoder(w)
	{{- if .Signature.OutputArg "httpResponseBody" }}
	err = encoder.Encode(o.{{ CapitalizeIdentifier "httpResponseBody" }})
	{{- else }}
	err = encoder.Encode(o)
	{{- end }}
	if err != nil {
		return errors.Trace(err)
	}
	return nil
}

// Mock{{ .Name }} sets up a mock handler for the {{ .Name }} function.
func (svc *Mock) Mock{{ .Name }}(handler func({{ .In }}) ({{ .Out }})) *Mock {
	svc.mock{{ .Name }} = handler
	return svc
}
{{ end}}

{{- range .Webs}}
// do{{ .Name }} handles the {{ .Name }} web handler.
func (svc *Mock) do{{ .Name }}(w http.ResponseWriter, r *http.Request) (err error) {
	if svc.mock{{ .Name }} == nil {
		return errors.New("mocked endpoint '{{ .Name }}' not implemented")
	}
	err = svc.mock{{ .Name }}(w, r)
	return errors.Trace(err)
}

// Mock{{ .Name }} sets up a mock handler for the {{ .Name }} web handler.
func (svc *Mock) Mock{{ .Name }}(handler func(w http.ResponseWriter, r *http.Request) (err error)) *Mock {
	svc.mock{{ .Name }} = handler
	return svc
}
{{ end }}

{{- range .Sinks }}
// do{{ .Name }} handles marshaling for the {{ .Name }} event sink.
func (svc *Mock) do{{ .Name }}({{ .In }}) ({{ .Out }}) {
	if svc.mock{{ .Name }} == nil {
		err = errors.New("mocked endpoint '{{ .Name }}' not implemented")
		return
	}
	{{ range .Signature.OutputArgs }}{{ .Name }}, {{ end }}err = svc.mock{{ .Name }}(ctx{{ range .Signature.InputArgs }}, {{ .Name }}{{ end }})
	err = errors.Trace(err)
	return
}

// Mock{{ .Name }} sets up a mock handler for the {{ .Name }} event sink.
func (svc *Mock) Mock{{ .Name }}(handler func({{ .In }}) ({{ .Out }})) *Mock {
	svc.mock{{ .Name }} = handler
	return svc
}
{{ end }}