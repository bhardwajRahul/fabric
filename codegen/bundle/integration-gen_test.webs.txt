{{ $host := .General.Host }}{{ $pkg := .PackageSuffix }}

{{- range .Webs }}
// {{ .Name }}TestCase assists in asserting against the results of executing {{ .Name }}.
type {{ .Name }}TestCase struct {
	t *testing.T
	res *http.Response
	err error
}

// StatusOK asserts no error and a status code 200.
func (tc *{{ .Name }}TestCase) StatusOK() *{{ .Name }}TestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, http.StatusOK)
	}
	return tc
}

// StatusCode asserts no error and a status code.
func (tc *{{ .Name }}TestCase) StatusCode(statusCode int) *{{ .Name }}TestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.Equal(tc.t, tc.res.StatusCode, statusCode)
	}
	return tc
}

// BodyContains asserts no error and that the response contains a string or byte array.
func (tc *{{ .Name }}TestCase) BodyContains(bodyContains any) *{{ .Name }}TestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyContains.(type) {
		case []byte:
			assert.True(tc.t, bytes.Contains(body, v), `"%v" does not contain "%v"`, body, v)
		case string:
			assert.True(tc.t, bytes.Contains(body, []byte(v)), `"%s" does not contain "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.True(tc.t, bytes.Contains(body, []byte(vv)), `"%s" does not contain "%s"`, string(body), vv)
		}
	}
	return tc
}

// BodyNotContains asserts no error and that the response does not contain a string or byte array.
func (tc *{{ .Name }}TestCase) BodyNotContains(bodyNotContains any) *{{ .Name }}TestCase {
	if assert.NoError(tc.t, tc.err) {
		body := tc.res.Body.(*httpx.BodyReader).Bytes()
		switch v := bodyNotContains.(type) {
		case []byte:
			assert.False(tc.t, bytes.Contains(body, v), `"%v" contains "%v"`, body, v)
		case string:
			assert.False(tc.t, bytes.Contains(body, []byte(v)), `"%s" contains "%s"`, string(body), v)
		default:
			vv := fmt.Sprintf("%v", v)
			assert.False(tc.t, bytes.Contains(body, []byte(vv)), `"%s" contains "%s"`, string(body), vv)
		}
	}
	return tc
}

// HeaderContains asserts no error and that the named header contains a string.
func (tc *{{ .Name }}TestCase) HeaderContains(headerName string, valueContains string) *{{ .Name }}TestCase {
	if assert.NoError(tc.t, tc.err) {
		assert.True(tc.t, strings.Contains(tc.res.Header.Get(headerName), valueContains), `header "%s: %s" does not contain "%s"`, headerName, tc.res.Header.Get(headerName), valueContains)
	}
	return tc
}

// Error asserts an error.
func (tc *{{ .Name }}TestCase) Error(errContains string) *{{ .Name }}TestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Contains(tc.t, tc.err.Error(), errContains)
	}
	return tc
}

// ErrorCode asserts an error by its status code.
func (tc *{{ .Name }}TestCase) ErrorCode(statusCode int) *{{ .Name }}TestCase {
	if assert.Error(tc.t, tc.err) {
		assert.Equal(tc.t, statusCode, errors.Convert(tc.err).StatusCode)
	}
	return tc
}

// NoError asserts no error.
func (tc *{{ .Name }}TestCase) NoError() *{{ .Name }}TestCase {
	assert.NoError(tc.t, tc.err)
	return tc
}

// Assert asserts using a provided function.
func (tc *{{ .Name }}TestCase) Assert(asserter func(t *testing.T, res *http.Response, err error)) *{{ .Name }}TestCase {
	asserter(tc.t, tc.res, tc.err)
	return tc
}

// Get returns the result of executing {{ .Name }}.
func (tc *{{ .Name }}TestCase) Get() (res *http.Response, err error) {
	return tc.res, tc.err
}

{{- if eq .Method "*" }}

/*
{{ .Name }}Get performs a GET request to the {{ .Name }} endpoint.

{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func {{ .Name }}Get(t *testing.T, ctx context.Context, url string) *{{ .Name }}TestCase {
	tc := &{{ .Name }}TestCase{t: t}
	var err error
	url, err = httpx.ResolveURL({{ $pkg }}api.URLOf{{ .Name }}, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`GET`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.{{ .Name }}(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

/*
{{ .Name }}Post performs a POST request to the {{ .Name }} endpoint.

{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func {{ .Name }}Post(t *testing.T, ctx context.Context, url string, contentType string, body any) *{{ .Name }}TestCase {
	tc := &{{ .Name }}TestCase{t: t}
	var err error
	url, err = httpx.ResolveURL({{ $pkg }}api.URLOf{{ .Name }}, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`POST`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.{{ .Name }}(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

{{- else if .MethodWithBody }}
/*
{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
If the body if of type io.Reader, []byte or string, it is serialized in binary form.
If it is of type url.Values, it is serialized as form data. All other types are serialized as JSON.
If a content type is not explicitly provided, an attempt will be made to derive it from the body.
*/
func {{ .Name }}(t *testing.T, ctx context.Context, url string, contentType string, body any) *{{ .Name }}TestCase {
	tc := &{{ .Name }}TestCase{t: t}
	var err error
	url, err = httpx.ResolveURL({{ $pkg }}api.URLOf{{ .Name }}, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := httpx.NewRequest(`{{ .Method }}`, url, body)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	if contentType != "" {
		r.Header.Set("Content-Type", contentType)
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.{{ .Name }}(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

{{- else }}
/*
{{ .Description }}

If a URL is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func {{ .Name }}(t *testing.T, ctx context.Context, url string) *{{ .Name }}TestCase {
	tc := &{{ .Name }}TestCase{t: t}
	var err error
	url, err = httpx.ResolveURL({{ $pkg }}api.URLOf{{ .Name }}, url)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r, err := http.NewRequest(`{{ .Method }}`, url, nil)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.{{ .Name }}(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}

{{- end }}

/*
{{ if ne .Method "*" }}{{ .Name }}Any performs a customized request to the {{ .Name }} endpoint.

{{ end -}}

{{ .Description }}

If a request is not provided, it defaults to the URL of the endpoint. Otherwise, it is resolved relative to the URL of the endpoint.
*/
func {{ .Name }}{{ if ne .Method "*" }}Any{{ end }}(t *testing.T, ctx context.Context, r *http.Request) *{{ .Name }}TestCase {
	tc := &{{ .Name }}TestCase{t: t}
	var err error
	if r == nil {
		r, err = http.NewRequest(`{{ if eq .Method "*" }}GET{{ else }}{{ .Method }}{{ end }}`, "", nil)
		if err != nil {
			tc.err = errors.Trace(err)
			return tc
		}
	}
	u, err := httpx.ResolveURL({{ $pkg }}api.URLOf{{ .Name }}, r.URL.String())
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	r.URL, err = url.Parse(u)
	if err != nil {
		tc.err = errors.Trace(err)
		return tc
	}
	ctx = context.WithValue(ctx, frame.ContextKey, r.Header)
	w := httpx.NewResponseRecorder()
	tc.err = utils.CatchPanic(func () error {
		return Svc.{{ .Name }}(w, r.WithContext(ctx))
	})
	tc.res = w.Result()
	return tc
}
{{ end }}