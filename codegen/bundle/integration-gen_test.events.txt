{{ $pkgSuffix := .PackageSuffix }}
{{- range .Events }}
{{- $t := .Signature.TestingT }}
// {{ .Name }}TestCase assists in asserting the sink of {{ .Name }}.
type {{ .Name }}TestCase struct {
	_t *testing.T
    _asserters []func(*testing.T)
    ctx context.Context
	{{- range .Signature.InputArgs }}
	{{ .Name }} {{ .Type }}
	{{- end }}
	{{- range .Signature.OutputArgs }}
	{{ .Name }} {{ .Type }}
	{{- end }}
	err error
	_dur time.Duration
}

// Expect asserts an exact match for the input arguments of the event sink.
func (_tc *{{ .Name }}TestCase) Expect({{ range $i, $e := .Signature.InputArgs }}{{ if $i }}, {{ end }}{{ .Name }} {{ .Type }}{{ end }}) *{{ .Name }}TestCase {
    _tc._asserters = append(_tc._asserters, func(t *testing.T) {
        {{- range .Signature.InputArgs }}
        {{- if eq .Type "time.Time" }}
        assert.True(t, {{ .Name }}.Equal(_tc.{{ .Name }}), "Expected %v, actual %v", {{ .Name }}, _tc.{{ .Name }})
        {{- else }}
        assert.Equal(t, {{ .Name }}, _tc.{{ .Name }})
        {{- end }}{{ end }}
    })
	return _tc
}

// CompletedIn checks that the duration of the operation is less than or equal the threshold.
func (_tc *{{ .Name }}TestCase) CompletedIn(threshold time.Duration) *{{ .Name }}TestCase {
	assert.LessOrEqual(_tc._t, _tc._dur, threshold)
	return _tc
}

// Assert sets a custom function to assert the input args of the event sink.
func (_tc *{{ .Name }}TestCase) Assert(asserter func({{ $t }} *testing.T, {{ .In }})) *{{ .Name }}TestCase {
	_tc._asserters = append(_tc._asserters, func(_t *testing.T) {
		asserter(_tc._t, _tc.ctx {{- range .Signature.InputArgs }}, _tc.{{ .Name }}{{ end }})
    })
	return _tc
}

// {{ .Name }} sets an event listener and returns a corresponding test case.
func {{ .Name }}({{ $t }} *testing.T, {{ .Out }}) *{{ .Name }}TestCase {
	_tc := &{{ .Name }}TestCase{
		_t: {{ $t }},
		{{- range .Signature.OutputArgs }}
		{{ .Name }}: {{ .Name }},
		{{- end }}
		err: err,
	}
    sequence ++
	t0 := time.Now()
	con := connector.New(fmt.Sprintf("%s.%d", "{{ .Name }}", sequence))
	{{ $pkgSuffix }}api.NewHook(con).{{ .Name }}(func({{ .In }}) ({{ .Out }}) {
		{{ $pkgSuffix }}api.NewHook(con).{{ .Name }}(nil)
		_tc.ctx = ctx
        {{- range .Signature.InputArgs }}
        _tc.{{ .Name }} = {{ .Name }}
        {{- end }}
		for _, asserter := range _tc._asserters {
			asserter(_tc._t)
		}
		_tc._dur = time.Since(t0)
		return {{ range .Signature.OutputArgs }}_tc.{{ .Name }}, {{ end }}_tc.err
	})
	App.Include(con)
	con.Startup()
	return _tc
}
{{ end }}